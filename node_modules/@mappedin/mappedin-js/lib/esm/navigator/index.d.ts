// Generated by dts-bundle v0.7.3

declare module '@mappedin/mappedin-js/lib/esm/navigator' {
    import NavigationGraph from '@mappedin/mappedin-js/lib/esm/navigator/NavigationGraph';
    import Navigator from '@mappedin/mappedin-js/lib/esm/navigator/Navigator';
    export { ACTION_TYPE, BEARING_TYPE } from '@mappedin/mappedin-js/lib/esm/navigator/Directive';
    export { Navigator, NavigationGraph };
    export type { IDirectionsResult, TSimplifyDirectionsOptions } from '@mappedin/mappedin-js/lib/esm/navigator/Navigator';
    export { E_MESSAGES } from '@mappedin/mappedin-js/lib/esm/navigator/Navigator';
    export { E_SDK_LOG_LEVEL, setLoggerLevel } from '@mappedin/mappedin-js/lib/esm/navigator/--/common/Mappedin.Logger';
}

declare module '@mappedin/mappedin-js/lib/esm/navigator/NavigationGraph' {
    import Edge from '@mappedin/mappedin-js/lib/esm/navigator/Edge';
    import IMap from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/IMap';
    import INode from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/INode';
    import IVortex from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/IVortex';
    export function getMapScale(map: IMap): number;
    export function getAngle(origin: INode, destination: INode): number;
    class NavigationGraph {
        edges: {
            [propName: string]: Edge[];
        };
        nodesById: {
            [propName: string]: INode;
        };
        mapsById: {
            [propName: string]: IMap;
        };
        constructor({ nodes, vortexes, maps, showVortexNames, }: {
            nodes: INode[];
            vortexes: IVortex[];
            maps: IMap[];
            showVortexNames?: boolean;
        });
        /**
          * aStar takes one or more origin node ids, one or more destination node ids
          * and returns an array of nodes that define the shortest path from an origin
          * a destination.
          *
          * @param originIds array - of one or more node ids
          * @param destinationNodeIds array - of onr or more node ids
          * @param accessible boolean - optional, if true directions will only take accessible route, defaults to false
          * @param includedVortexIds set - optional, exclude all the vertexes matching the given IDs
          * @param excludedVortexIds set - optional, exclude all the vertexes matching the given IDs
          * @param excludedNodeIds set - optional, exclude all the nodes matching the given IDs
          */
        aStar({ originIds, destinationNodeIds, accessible, includedVortexIds, excludedVortexIds, excludedNodeIds, }: {
            originIds: string[];
            destinationNodeIds: string[];
            accessible: boolean;
            includedVortexIds?: Set<string>;
            excludedVortexIds?: Set<string>;
            excludedNodeIds?: Set<string>;
        }): Edge[];
        getDistance(origin: INode, destination: INode): number;
        getShortestEuclideanDistance(origin: INode, destinations: INode[]): number;
    }
    export default NavigationGraph;
}

declare module '@mappedin/mappedin-js/lib/esm/navigator/Navigator' {
    import Directive from '@mappedin/mappedin-js/lib/esm/navigator/Directive';
    import Edge from '@mappedin/mappedin-js/lib/esm/navigator/Edge';
    import { TCoordinate } from '@mappedin/mappedin-js/lib/esm/navigator/Navigator.utils';
    import ILocation from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/ILocation';
    import IMap from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/IMap';
    import INode from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/INode';
    import IPolygon from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/IPolygon';
    import IVortex from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/IVortex';
    export enum E_MESSAGES {
            NO_VALID_PATH = "No Valid Path Available"
    }
    export function differenceBetweenAngles(a: any, b: any): number;
    export interface IDirectionsResult {
            distance: number;
            path: INode[];
            instructions: Directive[];
    }
    /**
        * @experimental
        * Configuration options for directions simplifying.
        */
    export type TSimplifyDirectionsOptions = {
            /**
                * Enable or disable simplifying.
                */
            enabled: boolean;
            /**
                * The radius of the buffer around the path.
                * @default 1.8
                */
            bufferRadius?: number;
    };
    class Navigator {
            constructor({ locations, nodes, vortexes, maps, polygons, showVortexNames, }: {
                    locations: ILocation[];
                    nodes: INode[];
                    vortexes: IVortex[];
                    maps: IMap[];
                    polygons?: IPolygon[];
                    showVortexNames?: boolean;
            });
            getClosestLocationInRay(startingEdge: Edge, angleThreshold?: number, distanceThreshold?: number): ILocation | null;
            /**
                * getDirections takes one or more origin node ids, one or more destination node ids
                * and returns a distance, array of directives, and an array of nodes that define the
                * path to take.
                *
                * The returned directives array defines nodes, vortexes, and locations along the path
                * along with text directions.
                *
                * @param originIds array - of one or more node ids
                * @param destinationNodeIds array - of onr or more node ids
                * @param accessible boolean - optional, if true directions will only take accessible route, defaults to false
                * @param departFrom ILocation - optional, id and name of a location to represent start of journey
                * @param arriveAt ILocation - optional, id and name of a location to represent end of journey
                * @param includedVortexIds set - optional, exclude all the vertexes matching the given IDs
                * @param excludedVortexIds set - optional, exclude all the vertexes matching the given IDs
                */
            getDirections({ originIds, destinationNodeIds, accessible, departFrom, arriveAt, includedVortexIds, excludedVortexIds, excludedNodeIds, simplify, }: {
                    originIds: string[];
                    includedVortexIds?: Set<string>;
                    excludedVortexIds?: Set<string>;
                    excludedNodeIds?: Set<string>;
                    destinationNodeIds: string[];
                    accessible: boolean;
                    departFrom?: ILocation;
                    arriveAt?: ILocation;
                    simplify?: TSimplifyDirectionsOptions;
            }): IDirectionsResult;
            /**
                * Iterates through each N step node and determines if a direct line to the next M step node intersects any polygons.
                * If it doesn't, remove all steps between the two.
                */
            simplifySteps(steps: Edge[], geometryEdges: TCoordinate[][], bufferRadius: number): Edge[];
    }
    export default Navigator;
}

declare module '@mappedin/mappedin-js/lib/esm/navigator/Directive' {
    import ILocation from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/ILocation';
    import IMap from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/IMap';
    import INode from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/INode';
    export enum ACTION_TYPE {
        DEPARTURE = "Departure",
        TAKEVORTEX = "TakeVortex",
        EXITVORTEX = "ExitVortex",
        TURN = "Turn",
        ARRIVAL = "Arrival"
    }
    export enum BEARING_TYPE {
        STRAIGHT = "Straight",
        RIGHT = "Right",
        SLIGHTRIGHT = "SlightRight",
        LEFT = "Left",
        SLIGHTLEFT = "SlightLeft"
    }
    export enum VORTEX_DIRECTION_TYPE {
        UP = "up",
        DOWN = "down",
        NONE = "none"
    }
    interface IActionDeparture {
        type: ACTION_TYPE.DEPARTURE;
    }
    interface IActionArrival {
        type: ACTION_TYPE.ARRIVAL;
    }
    interface IActionTakeVortex {
        type: ACTION_TYPE.TAKEVORTEX;
        toMap: IMap;
        fromMap: IMap;
        direction: VORTEX_DIRECTION_TYPE;
    }
    interface IActionExitVortex {
        type: ACTION_TYPE.EXITVORTEX;
        toMap: IMap;
        fromMap: IMap;
    }
    interface IActionTurn {
        type: ACTION_TYPE.TURN;
        bearing: BEARING_TYPE;
        referencePosition?: string;
    }
    export type IAction = IActionArrival | IActionDeparture | IActionTurn | IActionTakeVortex | IActionExitVortex;
    class Directive {
        node?: INode;
        instruction: string;
        action?: IAction;
        atLocation?: ILocation;
        type?: BEARING_TYPE;
        distance: number;
        constructor({ origin, action, distance, atLocation, instruction, }: {
            origin?: INode;
            action?: IAction;
            distance?: number;
            atLocation?: ILocation;
            instruction?: string;
        });
    }
    export default Directive;
}

export declare const MI_DEBUG_KEY = "mi-debug";
export declare enum E_SDK_LOG_LEVEL {
    LOG = 0,
    WARN = 1,
    ERROR = 2,
    SILENT = 3
}
export declare function setLoggerLevel(level: E_SDK_LOG_LEVEL): void;
declare const Logger: {
    logState: E_SDK_LOG_LEVEL;
    log(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
    assert(...args: any[]): void;
    time(label: string): void;
    timeEnd(label: string): void;
};
export default Logger;

declare module '@mappedin/mappedin-js/lib/esm/navigator/Edge' {
    import INode from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/INode';
    import IVortex from '@mappedin/mappedin-js/lib/esm/navigator/interfaces/IVortex';
    class Edge {
        origin: INode;
        destination: INode;
        vortex?: IVortex;
        distance: number;
        angle: number;
        weight: number;
        constructor({ origin, destination, vortex, elevationDelta, distance, angle, pathWeight, }: {
            origin: INode;
            destination: INode;
            vortex?: IVortex;
            elevationDelta?: number;
            distance?: number;
            angle?: number;
            pathWeight?: number;
        });
    }
    export default Edge;
}

declare module '@mappedin/mappedin-js/lib/esm/navigator/interfaces/IMap' {
    interface IGeoReference {
        target: {
            x: number;
            y: number;
        };
        control: {
            x: number;
            y: number;
        };
    }
    interface IMap {
        id: string;
        name: string;
        shortName: string;
        elevation?: number;
        scale?: number;
        x_scale?: number;
        georeference?: IGeoReference[];
        [propName: string]: any;
    }
    export default IMap;
}

declare module '@mappedin/mappedin-js/lib/esm/navigator/interfaces/INode' {
    interface INode {
        id: string;
        x: number;
        y: number;
        map: string;
        externalId?: string;
        [propName: string]: any;
    }
    export default INode;
}

declare module '@mappedin/mappedin-js/lib/esm/navigator/interfaces/IVortex' {
    interface IVortex {
        id: string;
        name: string;
        type: string;
        weight: number;
        multiplier: number;
        [propName: string]: any;
    }
    export default IVortex;
}

declare module '@mappedin/mappedin-js/lib/esm/navigator/Navigator.utils' {
    export type TCoordinate = {
            x: number;
            y: number;
    };
    /**
        * Modified line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
        * Determines the intersection point of two line segments.
        * Return null if the lines don't intersect.
        */
    export function getLineIntersection(line1Point1: TCoordinate, line1Point2: TCoordinate, line2Point1: TCoordinate, line2Point2: TCoordinate): {
            x: number;
            y: number;
    } | null;
    /**
        * Offsets a line between two nodes by a certain distance.
        */
    export function getOffsetLine(point1: TCoordinate, point2: TCoordinate, offset: number): {
            x: number;
            y: number;
    }[];
    /**
        * Determines if there is a line of sight between two nodes.
        */
    export function hasLineOfSight(origin: TCoordinate, destination: TCoordinate, edges?: TCoordinate[][], bufferRadius?: number): boolean;
}

declare module '@mappedin/mappedin-js/lib/esm/navigator/interfaces/ILocation' {
    interface ILocation {
        id: string;
        name: string;
        [propName: string]: any;
    }
    export default ILocation;
}

declare module '@mappedin/mappedin-js/lib/esm/navigator/interfaces/IPolygon' {
    interface IPolygon {
        id: string;
        map: string;
        layer?: string;
        layerId?: string;
        externalId?: string;
        name?: string;
        vertexes: {
            x: number;
            y: number;
        }[];
    }
    export default IPolygon;
}

