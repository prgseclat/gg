// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../cms/@mappedin/mvf
//   ../../../cms/minisearch
//   ../../../cms/geojson

declare module '@mappedin/mappedin-js/lib/esm/get-venue' {
    import type { TAllGetVenueOptions, TGetVenueOptions, TGetVenueOptionsInternal, TVenueMetadata, ThingsOption } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.types';
    import { Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin';
    import { defaultThings } from '@mappedin/mappedin-js/lib/esm/get-venue/default-things';
    import { GET_VENUE_EVENT } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * This is how we can avoid bundling in node-fetch (via isomorphic fetch),
        * which keeps popping up in security advisories
        * This is a pattern that most isomorphic libraries appear to use,
        * where when running in node, you can pass your own fetch function
        * as one is not provided by Node.js.
        *
        */
    export function isomorphicFetch(): Window['fetch'];
    /**
        * Overwrite the internal `fetch` function with your own. Typically for use in Node.js and Jest.
        *
        * @example
        * ```js
        * const { getVenue } = require("@mappedin/mappedin-js/lib/node/index");
        * setFetchFn(require("node-fetch-commonjs"));
        * ```
        *
        */
    export function setFetchFn(fetchFn: any): void;
    /** Classes */
    export { MappedinCollectionType, MappedinNavigatable, MappedinNode, MappedinLocation, MappedinPolygon, MappedinCategory, MappedinDirections, MappedinDestinationSet, MappedinVortex, MappedinVenue, MappedinRankings, MappedinEvent, MappedinLocationState, MappedinMap, MappedinCoordinate, MappedinMapGroup, findPreferredLanguage, Mappedin, } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * @internal
        * @hidden
        *
        * Export this only so our internal pre-built products can use it. We don't want to document it for external developers.
        */
    export { default as CustomerAnalytics } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.CustomerAnalytics';
    export type { TMappedinDirective } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinDirections';
    export type { IDirectionsResult } from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator';
    export type { TOperationHoursMap } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinLocation';
    export type { TMappedinCoordinateOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinCoordinate';
    export type { TDirectionToOptions, TTHINGS, TAccessors } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    export type { ThingsOption };
    export { OfflineSearch } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.OfflineSearch';
    export type { TMappedinOfflineSearchOptions, TMappedinOfflineSearchResult, TMappedinOfflineSearchSuggestions, TMappedinOfflineAllSearchMatch, TMappedinOfflineSearchAllOptions, } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.OfflineSearch';
    export { defaultThings };
    /** API data types */
    export type { TLocationType, TNode, TImage, TLogo, TGalleryImage, TPhone, TSocial, TColor, TVortex, TPicture, TOpeningHours, TSiblingGroup, TState, TCategory, TEvent, TGeoReference, TMap, TMapGroup, TBuilding, TLocation, TPolygon, TPolygonRanking, TVenue, TMappedinAPI, } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    export type { TGetVenueOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.types';
    import { MAP_RENDER_MODE } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.types';
    import { ParsedMVF } from '@mappedin/mvf';
    export { MAP_RENDER_MODE, GET_VENUE_EVENT };
    /**
        * @internal
        */
    export function parseOptions<T extends TAllGetVenueOptions>(options: T): TGetVenueOptionsInternal<T>;
    /**
        * @internal
        */
    export function getVenueMVF(userOptions: TGetVenueMVFOptions): Promise<Mappedin>;
    /**
        * @experimental
        * Get venue data for a map created in Mappedin Maker.
        * @param userOptions
        * @example
        * ```ts
        * const mappedin = await getVenueMaker({
        * 	key: '<Your Maker Key>',
        * 	secret: '<Your Maker Secret>',
        * 	mapId: '<Your Maker Map ID>',
        * });
        * ```
        * @returns {@link Mappedin} object with data from the Maker map.
        */
    export function getVenueMaker(userOptions: TGetVenueMakerOptions): Promise<Mappedin>;
    /**
        * Get Venue Data for a Mappedin Venue
        */
    export function getVenue(userOptions: TGetVenueOptions): Promise<Mappedin>;
    export function getVenueMetadata(userOptions: TGetVenueOptions): Promise<TVenueMetadata>;
    /**
        * @internal
        */
    export function __setGetVenueMock(fn: any): void;
    export type TGetVenueBundleOptions = TGetVenueOptions & {
            bundleBaseUri?: string;
            version?: string;
            /**
                * Parse bundle and convert images to blobs. Disabled in React Native
                * @private
                */
            shouldPopulateBundledImagesAsBlobs?: boolean;
    };
    /** @internal */
    export type TGetVenueMVFOptions = TGetVenueBundleOptions & {
            onMVFParsed?: (mvf: ParsedMVF) => void;
            /**
                * Override initial MVF data
                */
            override?: Partial<Pick<ParsedMVF, 'styles.json'>>;
    };
    /**
        * @experimental
        * Options for {@link getVenueMaker}.
        */
    export type TGetVenueMakerOptions = {
            /**
                * Maker auth key.
                */
            key: string;
            /**
                * Maker auth secret.
                */
            secret: string;
            /**
                * Maker map ID.
                */
            mapId: string;
            /**
                * Optionally provide a custom base URL for the Maker map API request.
                */
            bundleBaseUri?: string;
            /**
                * Optionally provide a custom base URL for the Maker auth token request.
                */
            authBaseUri?: string;
            /**
                * Whether or not to emit analytics events.
                * @default true
                */
            emitAnalyticsEvents?: boolean;
            /**
                * Callback for when the Maker map data has been fetched and parsed as Mappedin Venue Format (MVF) data. This occurs before the {@link Mappedin} object is hydrated.
                * @param mvf Parsed MVF data.
                */
            onMVFParsed?: (mvf: ParsedMVF) => void;
    };
    /**
        * @deprecated
        * Fetching an offline Venue bundle
        * It is possible to download the venue bundle with all assets built in, which allows for caching/offline solutions.
        * Note 1: This requires enabling from Mappedin's Customer Solutions team.
        * Note 2: This may behave a lot slower for large venues, especially those with many images. We are actively working on improving load times.
        */
    export function getVenueBundle(userOptions: TGetVenueBundleOptions): Promise<Mappedin>;
    /**
        * Get the bundle URL and updated_at time.
        * @internal
        */
    export function getVenueBundleURL(userOptions: TGetVenueBundleOptions): Promise<{
            url: string;
            updated_at: string;
    }>;
    /**
        * Download a bundle and return a Mappedin instance
        * @internal
        */
    export function downloadBundle(userOptions: TGetVenueBundleOptions, { url, updated_at }: {
            url: any;
            updated_at: any;
    }): Promise<Mappedin>;
    /**
        * Get the bundle URL and updated_at time.
        * @internal
        */
    export function getVenueMVFURL(userOptions: TGetVenueBundleOptions): Promise<{
            url: string;
            updated_at: string;
    }>;
    /**
        * @internal
        */
    export function downloadVenueBundleMVF(options: TGetVenueBundleOptions): Promise<Uint8Array>;
    /**
        * Represents the options for getting an access token.
        *
        * @internal
        */
    export type TGetAccessTokenOptions = Pick<TGetVenueMakerOptions, 'authBaseUri' | 'key' | 'secret'>;
    /**
        * Get an access token.
        *
        * @param userOptions
        */
    export function getMakerAccessToken(userOptions: TGetAccessTokenOptions): Promise<{
            access_token: string;
            expires_in: number;
    }>;
    export function getMakerBundleURL(userOptions: TGetVenueMakerOptions, token: string): Promise<{
            url: string;
            updated_at: string;
    }>;
    export function downloadMVF(userOptions: TGetVenueMakerOptions, accessToken: string): Promise<Uint8Array>;
    /**
        * Returns a {@link Mappedin} object hydrated with JSON data.
        * @param {string|Object} mappedinSerializableData A JSON string or object representing a venue.
        * @param {boolean} shouldPopulateBundledImagesAsBlobs
        * @returns {Mappedin} A new Mappedin object with data from the mappedinSerializableData parameter.
        */
    export function hydrateVenue(mappedinSerializableData: any, shouldPopulateBundledImagesAsBlobs?: boolean): Promise<Mappedin>;
    /**
        * @internal
        * Returns a {@link Mappedin} object hydrated with MVF data.
        */
    export function hydrateVenueMVF(mvfData: ParsedMVF): Promise<Mappedin>;
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.types' {
    import type { TGetVenueMVFOptions, TGetVenueMakerOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/';
    import type { DefaultThings } from '@mappedin/mappedin-js/lib/esm/get-venue/default-things';
    export type MergedThings = {
            [key in keyof DefaultThings]: string[];
    } & {
            [k: string]: string[];
    };
    export type ThingsOption = Partial<MergedThings>;
    export type TGetVenueOptions = {
            accessToken?: string;
            clientId?: string;
            clientSecret?: string;
            baseUrl?: string;
            includeHidden?: boolean;
            noAuth?: boolean;
            perspective?: string;
            language?: string;
            /**
                * Fallback to navigator language if the language is not available
                * @default true
                */
            fallbackToNavigatorLanguages?: boolean;
            headers?: {
                    [key in string]: string;
            };
            venue: string;
            /**
                * An object specifying additional properties to fetch for each data item.
                * Each key represents a data item (e.g., 'locations', 'nodes'), and the value is an array of strings indicating extra properties to be included.
                * @example
                * For example:
                * ```
                * getVenue({
                *   venue: 'some-venue',
                *   things: { vortexes: [ 'material' ]
                * }})
                * ```
                */
            things?: ThingsOption;
            useDraftData?: boolean;
            platformString?: string;
            emitAnalyticsEvents?: boolean;
            secure?: boolean;
            preloadMapGeometry?: boolean;
    };
    export type TProcessedMVFOptions = TGetVenueMakerOptions & {
            emitAnalyticsEvents: boolean;
            clientId: string;
            clientSecret: string;
            venue: string;
            accessToken: string;
    };
    export type TAllGetVenueOptions = TGetVenueOptions | TGetVenueMVFOptions | (TProcessedMVFOptions & {
            perspective?: string;
    });
    export type TGetVenueOptionsInternal<T extends TAllGetVenueOptions> = Omit<T & {
            baseUrl?: string;
            supplementaryUrl?: string;
            noAuth?: boolean;
            includeHidden?: boolean;
            apiGateway?: string;
            authorization?: string;
            headers?: any;
    }, 'things'> & {
            things?: MergedThings;
    };
    export type TVenueMetadata = {
            languages: {
                    name: string;
                    code: string;
            }[];
            hasSecureAssets: boolean;
    };
    export enum MAP_RENDER_MODE {
            /** Each polygon, its geometry and mesh are sent to the GPU every render frame.
                * This was the default rendering mode before 4.0.17
                */
            MULTI_GEOMETRY = "MULTI_GEOMETRY",
            /** Polygons' geometries are grouped by material and merged together, resulting in far fewer
                * draw calls to the GPU. Default rendering mode since 4.0.17
                */
            SINGLE_GEOMETRY = "SINGLE_GEOMETRY"
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin' {
    import { Navigator } from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator';
    import type { TAllGetVenueOptions, TGetVenueOptions, TGetVenueOptionsInternal } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.types';
    import type { MappedinNode, MappedinPolygon, MappedinLocation, MappedinCategory, MappedinVortex, MappedinVenue, MappedinTheme, MappedinRankings, MappedinLocationRankings, MappedinEvent, MappedinLocationState, MappedinMap, MappedinMapGroup, GET_VENUE_PAYLOAD, TAccessors } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import { GET_VENUE_EVENT } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import type { IAnalytics } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.CustomerAnalytics';
    import type { ParsedMVF } from '@mappedin/mvf';
    import type { ParsedMVFv1 } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.MVF.types';
    import { PubSub } from '@mappedin/mappedin-js/lib/esm/get-venue/pub-sub.typed';
    export const defaultOptions: TGetVenueOptionsInternal<TGetVenueOptions>;
    export class Mappedin extends PubSub<GET_VENUE_PAYLOAD, GET_VENUE_EVENT> {
            #private;
            perspective: any;
            things: any;
            options: TGetVenueOptionsInternal<TAllGetVenueOptions> & Pick<TGetVenueOptions, 'language' | 'fallbackToNavigatorLanguages'>;
            updatedAt?: string;
            categories: MappedinCategory[];
            locations: MappedinLocation[];
            vortexes: MappedinVortex[];
            maps: MappedinMap[];
            nodes: MappedinNode[];
            polygons: MappedinPolygon[];
            venue: MappedinVenue;
            events: MappedinEvent[];
            mapGroups: MappedinMapGroup[];
            themes: MappedinTheme[];
            locationStates: MappedinLocationState[];
            rankings?: MappedinRankings;
            currentLanguage: {
                    name: string;
                    code: string;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _categoriesById?: {
                    [id: string]: MappedinCategory;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationsById?: {
                    [id: string]: MappedinLocation;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _vortexesById?: {
                    [id: string]: MappedinVortex;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _mapsById?: {
                    [id: string]: MappedinMap;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _nodesById?: {
                    [id: string]: MappedinNode;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _polygonsById?: {
                    [id: string]: MappedinPolygon;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _eventsById?: {
                    [id: string]: MappedinEvent;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _mapGroupsById?: {
                    [id: string]: MappedinMapGroup;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationStatesById?: {
                    [id: string]: MappedinLocationState;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationRankingsById?: {
                    [id: string]: MappedinLocationRankings;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _rankingsById?: {
                    [id: string]: MappedinRankings;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _categoriesByExternalId?: {
                    [id: string]: MappedinCategory;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationsByExternalId?: {
                    [id: string]: MappedinLocation;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _vortexesByExternalId?: {
                    [id: string]: MappedinVortex;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _mapsByExternalId?: {
                    [id: string]: MappedinMap;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _nodesByExternalId?: {
                    [id: string]: MappedinNode;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _polygonsByExternalId?: {
                    [id: string]: MappedinPolygon;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _eventsByExternalId?: {
                    [id: string]: MappedinEvent;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _mapGroupsByExternalId?: {
                    [id: string]: MappedinMapGroup;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationStatesByExternalId?: {
                    [id: string]: MappedinLocationState;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _locationRankingsByExternalId?: {
                    [id: string]: MappedinLocationRankings;
            };
            /**
                * @hidden
                * @internal
                * @deprecated Use {@link Mappedin.getCollectionItemById} instead
                */
            _rankingsByExternalId?: {
                    [id: string]: MappedinRankings;
            };
            getCollectionItemById<T extends keyof TAccessors, I extends string>(name: T, id: I): TAccessors[T] | null;
            /**
                * @hidden
                * @internal
                */
            hydrateFromMVF(mvfData: ParsedMVF): Promise<undefined>;
            /**
                * @hidden
                * @internal
                */
            hydrateFromMVFv1(mvfData: ParsedMVFv1): Promise<undefined>;
            /**
                * Change the language of the venue. This will trigger a re-fetch of the venue data and emit a
                * {GET_VENUE_EVENT.LANGUAGE_CHANGED} event.
                *
                * @param languageCode The language code to change to
                * @param cache Whether or not to cache the current language so it doesn't need to be re-fetched
                */
            changeLanguage: (languageCode: string, cache?: boolean) => Promise<void>;
            /**
                *
                * @experimental Hydrate the Mappedin instance using a response from either {@link Mappedin.toString}, {@link getVenueBundle} or by downloading the bundle manually
                * @param mappedinSerializableData Mappedin data that was serialized or exported as JSON
                * @param shouldPopulateBundledImagesAsBlobs Takes the scenes and images from a bundle and maps them as blobs to where they exist as URLs in the bundle. False by default
                */
            hydrate: (mappedinSerializableData: string | Record<string, unknown>, shouldPopulateBundledImagesAsBlobs?: boolean, updateInPlace?: boolean) => Promise<undefined>;
            images: any;
            imageBinaries?: Map<string, Uint8Array>;
            scenes: any;
            fetch(updateInPlace?: boolean): Promise<void>;
            /**
                * @deprecated Use {@link hydrateVenue} instead
                */
            constructor(options: TGetVenueOptionsInternal<TAllGetVenueOptions>);
            analytics: IAnalytics;
            /**
                * @hidden
                */
            navigator?: Navigator;
            /**
                * Export venue data to JSON (for storage, encryption, etc)
                */
            toJSON: (includeOptions?: boolean) => any;
            /**
                * Export venue data to String
                */
            toString: (includeOptions?: boolean) => string;
    }
    /**
        * Finds the ideal language for the venue based on the following priority:
        * 1. User specified language (if it exists in venue languages)
        * 2. Browser navigator languages (if fallback is enabled)
        * 3. Venue's default language
        *
        * @param venue - The MappedinVenue object containing available languages
        * @param options - Configuration options
        * @param options.language - Preferred language code to use
        * @param options.fallbackToNavigatorLanguages - Whether to use browser's language settings as fallback (defaults to true)
        * @returns An object containing the selected language code and name, or undefined if no language is found
        */
    export function findPreferredLanguage(venue: MappedinVenue, options: {
            language?: string;
            fallbackToNavigatorLanguages?: boolean;
    }): {
            code: string;
            name: string;
    } | undefined;
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/default-things' {
    export const defaultThings: {
        venue: string[];
        nodes: string[];
        vortexes: string[];
        polygons: string[];
        locations: string[];
        categories: string[];
        maps: string[];
        mapGroups: string[];
        themes: string[];
        rankings: string[];
    };
    export type DefaultThings = typeof defaultThings;
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/internal' {
    import { MappedinNavigatable } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinNavigatable';
    import { MappedinNode } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinNode';
    import { MappedinPolygon } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinPolygon';
    import { MappedinLocation } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinLocation';
    import { MappedinCategory } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinCategory';
    import { MappedinDirections } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinDirections';
    import { MappedinDestinationSet } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinDestinationSet';
    import { MappedinVortex } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinVortex';
    import { MappedinVenue } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinVenue';
    import { MappedinTheme } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinTheme';
    import { MappedinRankings } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinRankings';
    import { MappedinLocationRankings } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinLocationRankings';
    import { MappedinEvent } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinEvent';
    import { MappedinLocationState } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinLocationState';
    import { MappedinMap } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinMap';
    import { MappedinCoordinate } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinCoordinate';
    import { MappedinMapGroup } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinMapGroup';
    export { MappedinNavigatable, MappedinNode, MappedinPolygon, MappedinLocation, MappedinCategory, MappedinDirections, MappedinDestinationSet, MappedinVortex, MappedinVenue, MappedinTheme, MappedinRankings, MappedinLocationRankings, MappedinEvent, MappedinLocationState, MappedinMap, MappedinCoordinate, MappedinMapGroup, };
    export * from '@mappedin/mappedin-js/lib/esm/get-venue/utils';
    export { default as MappedinCache } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.cache';
    export enum MappedinCollectionType {
        CATEGORY = "categories",
        EVENT = "events",
        LOCATION = "locations",
        MAPGROUP = "mapGroups",
        MAP = "maps",
        NODE = "nodes",
        POLYGON = "polygons",
        VORTEX = "vortexes"
    }
    export type TAccessors = {
        [MappedinCollectionType.CATEGORY]: MappedinCategory;
        [MappedinCollectionType.EVENT]: MappedinEvent;
        [MappedinCollectionType.LOCATION]: MappedinLocation;
        [MappedinCollectionType.MAPGROUP]: MappedinMapGroup;
        [MappedinCollectionType.MAP]: MappedinMap;
        [MappedinCollectionType.NODE]: MappedinNode;
        [MappedinCollectionType.POLYGON]: MappedinPolygon;
        [MappedinCollectionType.VORTEX]: MappedinVortex;
    };
    export const THINGS: {
        categories: typeof MappedinCategory;
        locations: typeof MappedinLocation;
        vortexes: typeof MappedinVortex;
        maps: typeof MappedinMap;
        nodes: typeof MappedinNode;
        polygons: typeof MappedinPolygon;
        venue: typeof MappedinVenue;
        events: typeof MappedinEvent;
        mapGroups: typeof MappedinMapGroup;
        themes: typeof MappedinTheme;
        locationStates: typeof MappedinLocationState;
        rankings: typeof MappedinRankings;
    };
    export type TTHINGS = keyof typeof THINGS;
    export type { TDirectionToOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinNavigatable';
    export enum GET_VENUE_EVENT {
        LANGUAGE_CHANGED = 0
    }
    export type GET_VENUE_PAYLOAD = {
        [GET_VENUE_EVENT.LANGUAGE_CHANGED]: {
            name: string;
            code: string;
        };
    };
    export { Mappedin, findPreferredLanguage } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin';
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.CustomerAnalytics' {
    import type { MappedinNavigatable, MappedinLocation, MappedinCategory } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    type AnalyticsUserPosition = {
            bluedotTimestamp: number;
            latitude: number;
            longitude: number;
            floorLevel?: number;
            accuracy: number;
    };
    type AnalyticsOptions = {
            clientId?: string;
            clientSecret?: string;
            accessToken?: string;
            noAuth?: boolean;
            venue: string;
            testMode?: boolean | string;
            context?: string;
            platformString?: string;
    };
    interface IAnalytics {
            locationSelected(location: MappedinLocation): void;
            categorySelected(category: MappedinCategory): void;
            /**
                * @hidden
                * @internal
                * @deprecated
                */
            getDirections(start: MappedinNavigatable, end: MappedinNavigatable): void;
    }
    interface IInternalAnalytics extends IAnalytics {
            track(target: string, query: any): void;
            mapViewLoaded(type: '2d' | '3d', forced: boolean, benchmark: number, reason: string): void;
            getSessionID(): string;
            getDeviceID(): string;
            setGeolocationMode(mode: boolean): void;
            trackBlueDotEvent(blueDotEvent: Record<string, unknown>): void;
            trackSearch(searchAnalyticsObject: Record<string, unknown>): void;
            trackSearchSuggest(searchAnalyticsObject: Record<string, unknown>): void;
    }
    /**
        * @internal
        * @hidden
        * A singleton class to access the Mappedin Analytics platform. Correct usage will improve Smart Search results, and lead to more accurate insights.
        * This will be created for you as part of Mappedin.{{#crossLink "Mappedin/initialize:method"}}{{/crossLink}}, but you can also create one manually. You are mostly going to use `locationSelected`.
        *
        * @type {any}
        */
    class Analytics implements IInternalAnalytics {
            #private;
            static instance: Analytics | null;
            /**
                * The static method to create a singleton instance of the Analytics class.
                * @class Analytics
                * @param options {Object} A list of configuration options for the Analytics API.
                *	@param [options.clientId] {String} The same key you are using for getVenue. Handled automatically in Mapview.initialize()
                *	@param [options.clientSecret] {String} The same secret you are using for getVenue. Handled automatically in Mapview.initialize()
                *	@param [options.venue] {String} The same venue slug you are using for getVenue. Handled automatically in MapView.initialize()
                *	@param [options.context] {String} The context to pass with the analytics request. Defaults to "websdk".
                *	@param [options.noAuth] {Boolean} Whether authentication should not be sent with analytics requests.
                *	@param [options.testMode] {Boolean} Whether analytics events should be dropped because this is running in a test environment.
                * @returns {Analytics} The singleton instance of the Analytics class.
                */
            static create(options: AnalyticsOptions): Analytics;
            track(target: string, query: Record<string, any>): void;
            /**
                * This method should be called whenever the user's position changes. This information will be sent when a track call is made.
                * @param position {AnalyticsUserPosition} The user's current position.
                */
            updateAnalyticsUserPosition(position: Omit<AnalyticsUserPosition, 'bluedotTimestamp'> | undefined): void;
            /**
                * Whenever a location is selected, you should fire this event. What "selected" means can vary by venue,
                * but a good rule of thumb is that you fire the event whenever you would show the location's details.
                * Typically this is when the user taps it's polygon on the map, picks it from search results or a category list.
                * or deep links directly into the map.
                * @method locationSelected
                * @param location {MappedinLocation} The location the user selected.
                */
            locationSelected(location: any): void;
            /**
                * Whenever a category is selected, you should fire this event.
                * @method categorySelected
                * @param category {MappedinCategory} The category the user selected.
                */
            categorySelected(category: any): void;
            mapViewLoaded(type: any, forced: any, benchmark: any, reason: any): void;
            /**
                * Whenever a user requests directions, you should fire this event.
                * @method getDirections
                * @param start {MappedinLocation} The start location for wayfinding.
                * @param end {MappedinLocation} The end location for wayfinding.
                */
            getDirections(start: any, end: any): void;
            /**
                * Returns the active mi-session ID.
                */
            getSessionID(): string;
            /**
                * Sets the current global mi-session ID and overrides the local session ID.
                * @param sessionID {String} The session ID to be set.
                * @internal
                */
            static setSessionID(sessionID: string): void;
            /**
                * Sets the current global device ID and overrides the local device ID.
                * @param deviceId {String} The device ID to be set.
                * @internal
                */
            static setDeviceID(deviceId: string): void;
            /**
                * Clears the current global mi-session ID and reverts to the local session ID.
                * @internal
                */
            static clearSessionID(): void;
            getDeviceID(): string;
            /**
                * @param mode {Boolean} Indicates whether the user's geolocation is enabled.
                */
            setGeolocationMode(mode: any): void;
            /**
                * Track an event.
                * @method trackBlueDotEvent
                * @param event {String}
                * event param should be a property of the {{#crossLink "Analytics/BLUEDOT_EVENT:property"}}{{/crossLink}} property.
                */
            trackBlueDotEvent(blueDotEvent: any): void;
            trackSearch(searchAnalyticsObject: any): void;
            trackSearchSuggest(searchAnalyticsObject: any): void;
            /**
                * Sets the current global context of the Analytics class.
                * @method setContext
                * @param context {String} The Analytics context to be set.
                * @hidden
                */
            static setContext(context: any): void;
            /**
                * Sets the current global context of the Analytics class to undefined.
                * @method clearContext
                * @hidden
                */
            static clearContext(): void;
            /**
                * Destroys the singleton instance of the Analytics class.
                * @method destroy
                * @hidden
                */
            static destroy(): void;
            /**
                * Enum of valid bluedot events.
                * Pass a property of this into the {{#crossLink "Analytics/trackBlueDotEvent:method"}}{{/crossLink}} method.
                * Valid properties are: ATTEMPT_BLUEDOT, FOUND_POSITION, FOUND_FLOOR.
                * @property BLUEDOT_EVENT {Object}
                * @example
                *   Analytics.trackBlueDotEvent(Analytics.BLUEDOT_EVENT.ATTEMPT_BLUEDOT)
                */
            static BLUEDOT_EVENT: {
                    ATTEMPT_BLUEDOT: string;
                    FOUND_POSITION: string;
                    FOUND_FLOOR: string;
            };
    }
    export type { IAnalytics };
    export default Analytics;
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinDirections' {
    import { IDirectionsResult } from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator';
    import { ACTION_TYPE, BEARING_TYPE } from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/Directive';
    import type { MappedinNode, MappedinVortex, MappedinMap, Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    export interface IActionDeparture {
            type: ACTION_TYPE.DEPARTURE;
    }
    export interface IActionArrival {
            type: ACTION_TYPE.ARRIVAL;
    }
    export interface IActionTakeVortex {
            type: ACTION_TYPE.TAKEVORTEX;
            toMap: MappedinMap;
            fromMap: MappedinMap;
    }
    export interface IActionExitVortex {
            type: ACTION_TYPE.EXITVORTEX;
            toMap: MappedinMap;
            fromMap: MappedinMap;
    }
    export interface IActionTurn {
            type: ACTION_TYPE.TURN;
            bearing: BEARING_TYPE;
            referencePosition?: string;
    }
    export type IAction = IActionArrival | IActionDeparture | IActionTurn | IActionTakeVortex | IActionExitVortex;
    /** this is the "overloaded" version of the directive, with get-venue classes instead of stubs */
    export type TMappedinDirective = {
            node: MappedinNode;
            /**
                * Distance from the last instruction to the current. Useful for turn by turn navigation
                */
            distance: number;
            instruction: string;
            action?: IAction;
            atLocation?: MappedinVortex;
            type?: BEARING_TYPE;
    };
    /**
        * Directions Object
        */
    export class MappedinDirections {
            #private;
            /**
                * Total Distance in meters of the path.
                */
            distance: number;
            /**
                * The path as an array of {@link MappedinNode}
                */
            path: MappedinNode[];
            /**
                * An array of {@link MappedinDirective} that contains the instructions to get to the destination, which can be used for text based directions.
                */
            instructions: TMappedinDirective[];
            constructor(mappedin: Mappedin, directions: IDirectionsResult);
            toJSON(): IDirectionsResult;
    }
}

import NavigationGraph from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/NavigationGraph';
import Navigator from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/Navigator';
export { ACTION_TYPE, BEARING_TYPE } from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/Directive';
export { Navigator, NavigationGraph };
export type { IDirectionsResult, TSimplifyDirectionsOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/Navigator';
export { E_MESSAGES } from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/Navigator';
export { E_SDK_LOG_LEVEL, setLoggerLevel } from '@mappedin/mappedin-js/lib/esm/get-venue/--/common/Mappedin.Logger';

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinLocation' {
    import type { TLocation, TColor, TGalleryImage, TLogo, TOpeningHours, TPhone, TPicture, TSiblingGroup, TSocial } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    import type { MappedinNode, MappedinPolygon, MappedinCategory, MappedinLocationState, Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import { MappedinNavigatable, MappedinDirections, MappedinDestinationSet, TDirectionToOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    export function getCurrentLocationState(location: MappedinLocation, states: MappedinLocationState[], date?: Date): MappedinLocationState | undefined;
    export type TOperationHoursMap = {
            [key in string]: TOpeningHours[];
    };
    /**
        * A {@link MappedinLocation} is something like a store or washroom on a {@link MappedinMap}. It has an ID and will be linked to zero or more {@link MappedinNode}s and {@link MappedinPolygon}s.
        *
        * A Location's Nodes and Polygons can be on multiple Maps, or in multiple non-adjacent places on the same Map.
        *  For example, all washroom at a given Venue could belong to one Location, or a department store could live on multiple floors. A Washroom Location might a have a few Polygons spread throughout the Venue for each one that exists, but a single store might just have one presence, and therefore one Polygon. Some Locations just have a single point and only have Nodes.
        *
        * A Location can have more properties (typically things like 'name', 'externalId', 'type', 'categories', 'description', 'logo', etc).
        *
        * The {@link Mappedin} 'things' object is where you would specify what properties you want to download for Locations. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * See below for an example a 'things' object with available Location properties specified:
        *
        *	things: {
        *		venue: [],
        *		locations: ['venue', 'name', 'type', 'icon', 'logo', 'language', 'externalId', 'description', 'categories', 'phone', 'operationHours', 'social', 'tags', 'parents', 'sortOrder'],
        *		categories: [],
        *		maps: []
        * 	}
        *
        * @class MappedinLocation
        */
    export class MappedinLocation extends MappedinNavigatable {
            #private;
            static readonly __type = "MappedinLocation";
            readonly __type = "MappedinLocation";
            static is(instance: object): instance is MappedinLocation;
            states: TLocation['states'];
            id: string;
            name: string;
            type: string;
            description?: string;
            sortOrder?: number;
            logo?: TLogo;
            phone?: TPhone;
            social?: TSocial;
            color?: TColor;
            shortName?: string;
            detailsUrl?: string;
            tags?: string[];
            /**
                * @internal
                */
            toMap?: string;
            externalId?: string;
            showLabelWhenImagePresent?: boolean;
            showSmartLabelWhenImagePresent?: boolean;
            picture?: TPicture;
            operationHours?: TOpeningHours[] | undefined;
            siblingGroups?: TSiblingGroup[] | undefined;
            gallery?: TGalleryImage[] | undefined;
            amenity?: string | undefined;
            filterFlags?: string[];
            constructor(mappedin: Mappedin, data: any);
            /**
                * Polygons this Location is attached to.
                *
                * @property polygons
                * @type [MappedinPolygon]
                */
            get polygons(): MappedinPolygon[];
            set polygons(polygons: MappedinPolygon[]);
            /**
                * Nodes this Location is attached to.
                *
                * @property nodes
                * @type [MappedinNode]
                */
            get nodes(): MappedinNode[];
            set nodes(nodes: MappedinNode[]);
            /**
                * Parent of this Location, if any. Used in cases where one Location is inside another, more "important" Location.
                *
                * @property parent
                * @type MappedinLocation
                */
            get parent(): MappedinLocation | undefined;
            set parent(parent: MappedinLocation | undefined);
            /**
                * Specific instances of this location with different properties.
                * Typically, there will be at least one node or polygon defined,
                * plus one or more other properties that are different from the parent.
                * The remaining properties will be the same as the parent.
                * For example, suppose there is a location like this:
                *
                * ```json
                * {
                *   "id": "location-id-1",
                *   "name": "Location 1",
                *   "nodes": ["node-1", "node-2"],
                *   "polygons": ["polygon-1", "polygon-2"],
                *   "externalId": "externalId-1",
                *   "description": "Description 1",
                * }
                * ```
                *
                * (Note that for clarity, we have put strings in for nodes and polygons, but in practice they would be objects.)
                *
                * Then suppose it had an `instances` array that contained an object that looked like this:
                *
                * ```json
                * {
                *   "id": "instance-id-1",
                *   "name": "Location 1 - A",
                *   "nodes": ["node-1"],
                *   "polygons": ["polygon-1"],
                *   "externalId": "externalId-1-A",
                *   "description": "Description 1",
                * }
                * ```
                * This says "Location 1" is the parent location, and "Location 1 - A" is an instance of it. The instance has a different name, and a different external ID, and it only applies to node `node-1` and polygon `polygon-1`.
                * The ID will always be different, but other properties (like the description) are the same as the parent.
                *
                * Example use cases:
                * - A Mall may have a location with two nodes and one polygon. It may then have an instance with one of the nodes, and operating hours
                * that are different from the parent. This indicates that this instance is an entrance for the location that is accessible at different times, perhaps for an interior mall entrance, when the main location (and other, exterior entrance) is open later than the rest of the mall.
                * - An airport may have a location with several polygons and nodes, and an instance for each node (and corresponding polygon, if any) with a different siblingGroup. The location in the sibling group may be the airport terminal, or airside vs landside.
                * This would allow an application to show the location once in a search result, but offer UX to select the instance that is in the right terminal.
                *
                * Note: Instances are actual EnterpriseLocations. This means they have all the properties of a normal EnterpriseLocation, including an `instances` property, that will always be undefined. They also do NOT have a parent property, or any other explicit reference to the parent location. These instances are
                * only referenced from their parent location, and will not show up in other places in the map data. However, they should otherwise behave like normal EnterpriseLocations, being targetable for things like navigation and focus.
                */
            get instances(): MappedinLocation[];
            /**
                * Categories related to this location.
                *
                * @property categories
                * @type [MappedinCategory]
                */
            get categories(): MappedinCategory[];
            get state(): MappedinLocationState | undefined;
            clone(): MappedinLocation;
            get nodeOperationHours(): TOperationHoursMap;
            static hydrate(locations: any, mappedin: Mappedin): MappedinLocation[];
            static updateInPlace(mappedin: Mappedin, hydrateData?: any): Promise<void>;
            static fetch(mappedin: Mappedin): Promise<MappedinLocation[]>;
            /**
                *
                * Get Directions to a node, polygon, or location
                */
            directionsTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): MappedinDirections;
            directionsTo(destination: MappedinDestinationSet, options?: TDirectionToOptions): MappedinDirections[];
            /**
                *
                * Calculate distance between 2 nodes, polygons or locations
                */
            distanceTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): number;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinCoordinate' {
    import type { MappedinMap } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import { Mappedin, MappedinNode } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    export type TMappedinCoordinateOptions = {
            map: MappedinMap;
            mappedin: Mappedin;
            x: number;
            y: number;
            lat?: undefined;
            lon?: undefined;
    } | {
            map: MappedinMap;
            mappedin: Mappedin;
            x?: undefined;
            y?: undefined;
            lat: number;
            lon: number;
    };
    /**
        * A {@link MappedinCoordinate} represents a coordinate on a map, created using lat/lon.
        *
        * @class MappedinCoordinate
        */
    export class MappedinCoordinate {
            #private;
            static readonly __type = "MappedinCoordinate";
            readonly __type = "MappedinCoordinate";
            static is(instance: object): instance is MappedinCoordinate;
            /**
                * The Map that the Node is located on.
                *
                * @property map {MappedinMap}
                */
            map: MappedinMap;
            /**
                *  X coordinate in Mappedin Units
                * @property x {number}
                */
            get x(): number;
            /**
                * Y coordinate in Mappedin Units
                * @property y {number}
                */
            get y(): number;
            /**
                * Latitude
                */
            get lat(): number;
            /**
                * Longitude
                */
            get lon(): number;
            /**
                * @internal
                */
            constructor(options: TMappedinCoordinateOptions);
            /**
                *
                * Calculate distance between a coordinate and a {@link MappedinNode} or {@link MappedinCoordinate}
                *
                * @param destination Destination to measure real distance to
                * @returns distance in meters
                */
            absoluteDistanceTo(destination: MappedinCoordinate): number;
            /**
                * Get Nearest Node to Coordinate, which can then be used for navigation
                */
            get nearestNode(): MappedinNode;
            /**
                * Get the {@link MappedinNode}s within a radius of the {@link MappedinCoordinate}.
                * @param radius - The radius in metres.
                */
            nodesInRadius(radius: number): MappedinNode[];
            toJSON(): {
                    x: number;
                    y: number;
                    map: MappedinMap;
                    lat: number;
                    lon: number;
            };
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.OfflineSearch' {
    import type { SearchOptions } from 'minisearch';
    import { MappedinLocation, MappedinCategory, Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    export const removeAccents: (it: string) => string;
    export function tokenizeAndCaptureDelimiters(text: string): string[];
    export type { SearchOptions };
    /**
        * A {@link OfflineSearch} is an offline search module
        *
        *
        * @class OfflineSearch
        */
    export type TMappedinOfflineSearchAllOptions = {
            /**
                * Array of stopwords to ignore when searching, default: english stopwords
                */
            stopWords?: string[];
            /**
                * Index location tags - typically better to use either tags or descriptions, depending on what's available
                * @default true
                */
            searchTags?: boolean;
            /**
                * Index location descriptions - typically better to use either tags or descriptions, depending on what's available
                * @default true
                */
            searchDescriptions?: boolean;
            /**
                * Also index all tags for every location in every category (caution: this may slow down indexing and search)
                * @default false
                */
            searchTagsInCategories?: boolean;
            /**
                * Also index all tags for every location in every category (caution: this may slow down indexing and search)
                * @default false
                */
            searchDescriptionsInCategories?: boolean;
            /**
                * Initialize Search with a previously indexed JSON string (outputted by OfflineSearch.toJSON())
                */
            jsonIndex?: string;
            /**
                * Use the location polygons' rank in weighing results
                */
            useLocationRank?: boolean;
            /**
                * Emit Analytics events when doing search
                * @default true when running in production
                */
            emitAnalyticsEvents?: boolean;
            /**
                * Fine tune search constants
                */
            constants: {
                    /**
                        * Fuzziness index for location names and tags
                        * @default 0.09
                        */
                    PRIMARY_INDEX_FUZZYNESS: number;
                    /**
                        * Multiplier for location names (1 by default)
                        * @default 1
                        */
                    PRIMARY_INDEX_WEIGHT: number;
                    /**
                        * Multiplier for descriptions
                        * @default 0.025
                        */
                    SECONDARY_INDEX_WEIGHT: number;
                    /**
                        * Multiplier for location names
                        * @default 1
                        */
                    LOCATION_NAME_WEIGHT: number;
                    /**
                        * Multiplier for category names
                        * @default 0.5
                        */
                    CATEGORY_NAME_WEIGHT: number;
                    /**
                        * Multiplier for category locations' descriptions
                        * @default 0.0005
                        */
                    CATEGORY_LOCATION_DESCRIPTION_WEIGHT: number;
                    /**
                        * Multiplier for category locations' tags
                        * @default 0.0005
                        */
                    CATEGORY_LOCATION_TAGS_WEIGHT: number;
                    /**
                        * Multiplier for category locations' names
                        * @default 0.01
                        */
                    CATEGORY_LOCATION_NAME_WEIGHT: number;
                    /**
                        * Multiplier for location tags
                        * @default 0.05
                        */
                    PRIMARY_INDEX_TAGS_NAME_WEIGHT: number;
                    /**
                        * Default rank when one isn't available in the data, default = 1
                        * @default 1
                        */
                    LOCATION_DEFAULT_RANK: number;
                    /**
                        * Ratio of Fuzzy Searches of Location names and tags relative to exact
                        * @default 0.01
                        */
                    RATIO_OF_FUZZY_TO_EXACT: number;
                    /**
                        * Ratio of Prefix Searches of Location names and tags relative to exact
                        * @default 0.2
                        */
                    RATIO_OF_PREFIX_TO_EXACT: number;
            };
    };
    export type TMappedinOfflineAllSearchMatch = {
            /**
                * The term that was found
                */
            term: string;
            /**
                * Term's weight
                */
            weight: number;
            /**
                * What field the search matched on
                */
            matchesOn: string;
            /**
                * The value of that field
                */
            value?: string;
    };
    export type TMappedinOfflineSearchOptions = Partial<TMappedinOfflineSearchAllOptions>;
    export type TMappedinOfflineSearchResult = {
            /**
                * Type describing the object
                */
            type: 'MappedinLocation' | 'MappedinCategory' | 'Custom';
            /**
                * Details on why the result was returned
                */
            matches: TMappedinOfflineAllSearchMatch[];
            /**
                * Found object
                */
            object: MappedinLocation | MappedinCategory | Record<string, unknown>;
            /**
                * Total score of the result
                */
            score: number;
    };
    export type TMappedinOfflineSearchSuggestions = {
            /**
                * Total number of suggestions generated
                */
            total: number;
            /**
                * List of suggestions
                */
            hits: {
                    /**
                        * Suggestion text
                        */
                    text: string;
            }[];
    };
    /**
        * A {@link OfflineSearch} is an offline search module. It can be initialized at any time by passing the {@link Mappedin} object and a set of {@link TMappedinOfflineSearchOptions} options.
        *
        *
        * @class Mappedin.OfflineSearch
        */
    export class OfflineSearch {
            #private;
            constructor(
            /**
                * Mappedin Venue Object, typically returned by `getVenue`/`showVenue`
                */
            mappedin: Mappedin, options?: TMappedinOfflineSearchOptions);
            /**
                * Get Suggestions for term
                */
            suggest(
            /**
                * Search term
                */
            term: string): Promise<TMappedinOfflineSearchSuggestions>;
            /**
                * Search for a term
                */
            search(term: string): Promise<TMappedinOfflineSearchResult[]>;
            /**
                * Export search index to JSON for storage/caching - this would avoid having to re-index
                * on page reload
                */
            toJSON(): Promise<string>;
            /**
                * Add a custom query to the search index
                */
            addQuery(params: {
                    /**
                        * Query string to match for this object
                        */
                    query: string;
                    /**
                        * Object that is returned when query matches
                        */
                    object: MappedinLocation | MappedinCategory | Record<string, unknown>;
                    /**
                        * Optional weight to multiply by the score
                        */
                    weight?: number;
            }): Promise<void>;
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types' {
    /**
      * This file contains the API types for MappedinSDK - before they get turned into Classes
      */
    export type TLocationType = 'amenities' | 'tenant';
    export type TNode = {
        id: string;
        x: number;
        y: number;
        map: string;
        externalId?: string;
        paths: {
            node: string;
            map: string;
            weight?: number;
        }[];
        [propName: string]: any;
    };
    export type TImage = {
        original?: string;
        large?: string;
        '140x140'?: string;
        xxlarge?: string;
        xsmall?: string;
        '66x66'?: string;
        xlarge?: string;
        medium?: string;
        xxsmall?: string;
        small?: string;
    };
    export type TLogo = TImage;
    export type TGalleryImage = {
        image: TImage;
        caption?: string;
    };
    export type TPhone = {
        number?: string;
    };
    export type TSocial = {
        website?: string;
        twitter?: string;
        facebook?: string;
        instagram?: string;
    };
    export type TColor = {
        hex: string;
        opacity: number;
        rgba: string;
    };
    export type TVortex = {
        id: string;
        name: string;
        type: string;
        weight: number;
        multiplier: number;
        [propName: string]: any;
    };
    export type TPicture = {
        original?: string;
    };
    export type TOpeningHours = {
        '@type': string;
        opens: string;
        closes: string;
        dayOfWeek: string[];
        validFrom?: string;
        validThrough?: string;
    };
    export type TSiblingGroup = {
        label: string;
        siblings: string[];
    };
    export type TState = {
        type: string;
        start?: string;
        end?: string;
    };
    export type TCategory = {
        name?: string;
        externalId?: string;
        parents?: string[];
        id?: string;
        icon?: TPicture;
    };
    export type TEvent = {
        id: string;
        type: string;
        name: string;
        location?: string;
        description?: string;
        image?: TImage;
        startDate?: number;
        endDate?: number;
        showDate?: number;
    };
    export interface TGeoReference {
        target: {
            x: number;
            y: number;
        };
        control: {
            x: number;
            y: number;
        };
    }
    export interface TMap {
        id: string;
        name: string;
        shortName: string;
        elevation?: number;
        scale?: number;
        x_scale?: number;
        georeference?: TGeoReference[];
        [propName: string]: any;
    }
    export type TMapGroup = {
        name: string;
        id: string;
    };
    export type TBuilding = TLocation & {
        groupId: string;
    };
    export type TLocation = {
        id: string;
        name: string;
        type: string;
        nodes: {
            map: TMap['id'];
            node: TNode['id'];
        }[];
        polygons: {
            map: TMap['id'];
            id: TPolygon['id'];
        }[];
        categories: string[];
        description?: string;
        sortOrder?: number;
        logo?: TLogo;
        phone?: TPhone;
        social?: TSocial;
        color?: TColor;
        shortName?: string;
        detailsUrl?: string;
        parent?: string | null;
        tags?: string[];
        externalId?: string;
        picture?: TPicture;
        states?: TState[];
        operationHours?: TOpeningHours[] | undefined;
        siblingGroups?: TSiblingGroup[] | undefined;
        gallery?: TGalleryImage[] | undefined;
        [propName: string]: any;
    };
    export type TPolygon = {
        id: string;
        map: string;
        layer?: string;
        layerId?: string;
        externalId?: string;
        name?: string;
        entrances: {
            map: TMap['id'];
            id: TNode['id'];
        }[];
    };
    export type TPolygonRanking = {
        polygonId: string;
        entranceNodeId: string;
        score: number;
    };
    export type TLocationState = {
        id: string;
        name: string;
        value: string;
    };
    export type TVenue = {
        address?: string;
        city?: string;
        countrycode?: string;
        defaultMap?: string;
        externalId?: string;
        id?: string;
        latitude?: number;
        logo?: TLogo;
        longitude?: number;
        metadata?: any;
        name?: string;
        operationHours?: TOpeningHours[];
        postal?: string;
        slug?: string;
        state?: string;
        telephone?: string;
        tzid?: string;
        tzidOverride?: string;
        utcOffset?: string;
        website?: string;
    };
    export type TMappedinAPI = {
        nodes: TNode[];
        locations: TLocation[];
        categories: TCategory[];
        mapGroups: TMapGroup[];
        polygons: TPolygon[];
        maps: TMap[];
        themes: any;
        venue: TVenue;
        vortexes: TVortex[];
        locationStates?: TLocationState[];
        imageBinaries?: Map<string, Uint8Array>;
    };
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/' {
    import type { TAllGetVenueOptions, TGetVenueOptions, TGetVenueOptionsInternal, TVenueMetadata, ThingsOption } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.types';
    import { Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin';
    import { defaultThings } from '@mappedin/mappedin-js/lib/esm/get-venue/default-things';
    import { GET_VENUE_EVENT } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * This is how we can avoid bundling in node-fetch (via isomorphic fetch),
        * which keeps popping up in security advisories
        * This is a pattern that most isomorphic libraries appear to use,
        * where when running in node, you can pass your own fetch function
        * as one is not provided by Node.js.
        *
        */
    export function isomorphicFetch(): Window['fetch'];
    /**
        * Overwrite the internal `fetch` function with your own. Typically for use in Node.js and Jest.
        *
        * @example
        * ```js
        * const { getVenue } = require("@mappedin/mappedin-js/lib/node/index");
        * setFetchFn(require("node-fetch-commonjs"));
        * ```
        *
        */
    export function setFetchFn(fetchFn: any): void;
    /** Classes */
    export { MappedinCollectionType, MappedinNavigatable, MappedinNode, MappedinLocation, MappedinPolygon, MappedinCategory, MappedinDirections, MappedinDestinationSet, MappedinVortex, MappedinVenue, MappedinRankings, MappedinEvent, MappedinLocationState, MappedinMap, MappedinCoordinate, MappedinMapGroup, findPreferredLanguage, Mappedin, } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * @internal
        * @hidden
        *
        * Export this only so our internal pre-built products can use it. We don't want to document it for external developers.
        */
    export { default as CustomerAnalytics } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.CustomerAnalytics';
    export type { TMappedinDirective } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinDirections';
    export type { IDirectionsResult } from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator';
    export type { TOperationHoursMap } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinLocation';
    export type { TMappedinCoordinateOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/MappedinCoordinate';
    export type { TDirectionToOptions, TTHINGS, TAccessors } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    export type { ThingsOption };
    export { OfflineSearch } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.OfflineSearch';
    export type { TMappedinOfflineSearchOptions, TMappedinOfflineSearchResult, TMappedinOfflineSearchSuggestions, TMappedinOfflineAllSearchMatch, TMappedinOfflineSearchAllOptions, } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.OfflineSearch';
    export { defaultThings };
    /** API data types */
    export type { TLocationType, TNode, TImage, TLogo, TGalleryImage, TPhone, TSocial, TColor, TVortex, TPicture, TOpeningHours, TSiblingGroup, TState, TCategory, TEvent, TGeoReference, TMap, TMapGroup, TBuilding, TLocation, TPolygon, TPolygonRanking, TVenue, TMappedinAPI, } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    export type { TGetVenueOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.types';
    import { MAP_RENDER_MODE } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.types';
    import { ParsedMVF } from '@mappedin/mvf';
    export { MAP_RENDER_MODE, GET_VENUE_EVENT };
    /**
        * @internal
        */
    export function parseOptions<T extends TAllGetVenueOptions>(options: T): TGetVenueOptionsInternal<T>;
    /**
        * @internal
        */
    export function getVenueMVF(userOptions: TGetVenueMVFOptions): Promise<Mappedin>;
    /**
        * @experimental
        * Get venue data for a map created in Mappedin Maker.
        * @param userOptions
        * @example
        * ```ts
        * const mappedin = await getVenueMaker({
        * 	key: '<Your Maker Key>',
        * 	secret: '<Your Maker Secret>',
        * 	mapId: '<Your Maker Map ID>',
        * });
        * ```
        * @returns {@link Mappedin} object with data from the Maker map.
        */
    export function getVenueMaker(userOptions: TGetVenueMakerOptions): Promise<Mappedin>;
    /**
        * Get Venue Data for a Mappedin Venue
        */
    export function getVenue(userOptions: TGetVenueOptions): Promise<Mappedin>;
    export function getVenueMetadata(userOptions: TGetVenueOptions): Promise<TVenueMetadata>;
    /**
        * @internal
        */
    export function __setGetVenueMock(fn: any): void;
    export type TGetVenueBundleOptions = TGetVenueOptions & {
            bundleBaseUri?: string;
            version?: string;
            /**
                * Parse bundle and convert images to blobs. Disabled in React Native
                * @private
                */
            shouldPopulateBundledImagesAsBlobs?: boolean;
    };
    /** @internal */
    export type TGetVenueMVFOptions = TGetVenueBundleOptions & {
            onMVFParsed?: (mvf: ParsedMVF) => void;
            /**
                * Override initial MVF data
                */
            override?: Partial<Pick<ParsedMVF, 'styles.json'>>;
    };
    /**
        * @experimental
        * Options for {@link getVenueMaker}.
        */
    export type TGetVenueMakerOptions = {
            /**
                * Maker auth key.
                */
            key: string;
            /**
                * Maker auth secret.
                */
            secret: string;
            /**
                * Maker map ID.
                */
            mapId: string;
            /**
                * Optionally provide a custom base URL for the Maker map API request.
                */
            bundleBaseUri?: string;
            /**
                * Optionally provide a custom base URL for the Maker auth token request.
                */
            authBaseUri?: string;
            /**
                * Whether or not to emit analytics events.
                * @default true
                */
            emitAnalyticsEvents?: boolean;
            /**
                * Callback for when the Maker map data has been fetched and parsed as Mappedin Venue Format (MVF) data. This occurs before the {@link Mappedin} object is hydrated.
                * @param mvf Parsed MVF data.
                */
            onMVFParsed?: (mvf: ParsedMVF) => void;
    };
    /**
        * @deprecated
        * Fetching an offline Venue bundle
        * It is possible to download the venue bundle with all assets built in, which allows for caching/offline solutions.
        * Note 1: This requires enabling from Mappedin's Customer Solutions team.
        * Note 2: This may behave a lot slower for large venues, especially those with many images. We are actively working on improving load times.
        */
    export function getVenueBundle(userOptions: TGetVenueBundleOptions): Promise<Mappedin>;
    /**
        * Get the bundle URL and updated_at time.
        * @internal
        */
    export function getVenueBundleURL(userOptions: TGetVenueBundleOptions): Promise<{
            url: string;
            updated_at: string;
    }>;
    /**
        * Download a bundle and return a Mappedin instance
        * @internal
        */
    export function downloadBundle(userOptions: TGetVenueBundleOptions, { url, updated_at }: {
            url: any;
            updated_at: any;
    }): Promise<Mappedin>;
    /**
        * Get the bundle URL and updated_at time.
        * @internal
        */
    export function getVenueMVFURL(userOptions: TGetVenueBundleOptions): Promise<{
            url: string;
            updated_at: string;
    }>;
    /**
        * @internal
        */
    export function downloadVenueBundleMVF(options: TGetVenueBundleOptions): Promise<Uint8Array>;
    /**
        * Represents the options for getting an access token.
        *
        * @internal
        */
    export type TGetAccessTokenOptions = Pick<TGetVenueMakerOptions, 'authBaseUri' | 'key' | 'secret'>;
    /**
        * Get an access token.
        *
        * @param userOptions
        */
    export function getMakerAccessToken(userOptions: TGetAccessTokenOptions): Promise<{
            access_token: string;
            expires_in: number;
    }>;
    export function getMakerBundleURL(userOptions: TGetVenueMakerOptions, token: string): Promise<{
            url: string;
            updated_at: string;
    }>;
    export function downloadMVF(userOptions: TGetVenueMakerOptions, accessToken: string): Promise<Uint8Array>;
    /**
        * Returns a {@link Mappedin} object hydrated with JSON data.
        * @param {string|Object} mappedinSerializableData A JSON string or object representing a venue.
        * @param {boolean} shouldPopulateBundledImagesAsBlobs
        * @returns {Mappedin} A new Mappedin object with data from the mappedinSerializableData parameter.
        */
    export function hydrateVenue(mappedinSerializableData: any, shouldPopulateBundledImagesAsBlobs?: boolean): Promise<Mappedin>;
    /**
        * @internal
        * Returns a {@link Mappedin} object hydrated with MVF data.
        */
    export function hydrateVenueMVF(mvfData: ParsedMVF): Promise<Mappedin>;
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.MVF.types' {
    import { MapId, ObstructionCollection, EntranceCollection, SpaceCollection, Style } from '@mappedin/mvf';
    import { FeatureCollection, MultiPolygon, Point, Polygon } from 'geojson';
    import { TImage, TMap, TNode, TOpeningHours, TPhone, TSiblingGroup, TSocial } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    export type WithIDs<T> = Map<string, T>;
    type ManifestFile = {
            type: 'file';
            name: string;
    };
    type ManifestFolder = {
            type: 'folder';
            name: string;
            children: ManifestFile[];
    };
    export type MVFStyle = Style & {
            type: string;
            width?: number;
    };
    export type MVFObstructionFeature = ObstructionCollection['features'][number];
    export type MVFEntranceFeature = EntranceCollection['features'][number];
    export type MVFSpaceFeature = SpaceCollection['features'][number];
    export type MVFv1PolygonLikeProperties = {
            id: string;
            altitude?: number;
            color?: string;
            externalId?: string | null;
            height?: number;
            opacity?: number;
            layer?: string;
            level: string;
            parent?: string | null;
    };
    export type MVFv1SpaceProperties = MVFv1PolygonLikeProperties & {
            entrances: {
                    level: TMap['id'];
                    id: TNode['id'];
            }[];
    };
    export type MVFv1ObstructionProperties = MVFv1PolygonLikeProperties;
    export type MVFv1ConnectionProperties = {
            id: string;
            /**
                * Indicates that a connection is accessible
                */
            accessible: boolean;
            /**
                * Array of node ids that this Connection connects with.
                */
            destinations: string[];
            level: string;
            multiplier: number;
            name: string;
            /**
                * Type of the connection such as `escalator` or `elevator`
                */
            type: string;
            weight: number;
    };
    export type MVFv1NodeProperties = {
            id: string;
            /**
                * Indicates that a node is accessible
                */
            accessible: boolean;
            /**
                * External id of a node is used to sync and connect to external systems to Mappedin data
                */
            externalId: string | null;
            level: string;
            multiplier: number;
            neighbors: string[];
            weight: number;
    };
    export type MVFv1LevelProperties = {
            id: string;
            abbreviation?: string;
            building?: string;
            elevation?: number;
            name: string;
    };
    export type MVFv1ManifestProperties = {
            /**
                * Name of the venue
                */
            name: string;
            folder_struct: (ManifestFolder | ManifestFile)[];
            /**
                * Mappedin Venue Format version number of the MVF bundle
                */
            version: string;
            /**
                * Timestamp when the MVF bundle was generated. E.g. `2022-02-25T16:26:09.908Z`
                */
            time: string;
    };
    export type MVFv1BuildingProperties = {
            id: string;
            name: string;
            venue: string;
    };
    export type MVFv1CategoryProperties = {
            id: string;
            name: string;
            picture?: TImage;
    };
    export type MVFv1LocationProperties = {
            id: string;
            address?: string | null;
            /**
                * Array of {@link MICategoryProperties | category} ids
                */
            categories: string[];
            /**
                * A text description of the location usually indicating what the location is used for
                */
            description?: string | null;
            /**
                * Email address to for contacting this location
                */
            email?: string | null;
            /**
                * External id used to connect Mappedin Location to an external system
                */
            externalId?: string | null;
            /**
                * Opening hours of the location
                */
            hours?: TOpeningHours[] | null;
            /**
                * Collection of links related to this location
                */
            links?: {
                    label: string;
                    url: string;
            }[] | null;
            logo?: TImage | null;
            /**
                * Name of the location. By default this is the string displayed in the location label
                */
            name: string;
            /**
                * Phone number for contacting this location
                */
            phone?: TPhone | null;
            picture?: TImage | null;
            services?: string | null;
            siblingGroups?: TSiblingGroup[] | null;
            /**
                * Social media links of the location
                */
            social?: TSocial | null;
            /**
                * Array of {@link MISpaceProperties | MVF Space} ids for this location
                */
            spaces?: {
                    id: string;
                    map: string;
            }[] | null;
            states?: {
                    type: string;
                    start?: string;
                    end?: string;
            }[] | null;
            type: string;
    };
    export type MVFv1ObstructionCollection = FeatureCollection<Polygon, MVFv1ObstructionProperties>;
    export type MVFv1SpaceCollection = FeatureCollection<Polygon, MVFv1SpaceProperties>;
    export type MVFv1ConnectionCollection = FeatureCollection<Point, MVFv1ConnectionProperties>;
    export type MVFv1NodeCollection = FeatureCollection<Point, MVFv1NodeProperties>;
    export type MVFv1LevelCollection = FeatureCollection<Polygon | MultiPolygon, MVFv1LevelProperties>;
    export type MVFv1ManifestCollection = FeatureCollection<Point, MVFv1ManifestProperties>;
    export type MVFv1BuildingCollection = FeatureCollection<Polygon, MVFv1BuildingProperties>;
    export type MVFv1CategoryCollection = FeatureCollection<null, MVFv1CategoryProperties>;
    export type MVFv1LocationCollection = FeatureCollection<null, MVFv1LocationProperties>;
    export type ParsedMVFv1 = {
            /**
                * @propertyNames { "pattern": "^m_[0-9a-z]{16}$" }
                */
            space: {
                    [mapId: MapId]: MVFv1SpaceCollection | undefined;
            };
            /**
                * @propertyNames { "pattern": "^m_[0-9a-z]{16}$" }
                */
            obstruction: {
                    [mapId: MapId]: MVFv1ObstructionCollection | undefined;
            };
            /**
                * @propertyNames { "pattern": "^m_[0-9a-z]{16}$" }
                */
            level: {
                    [mapId: MapId]: MVFv1LevelCollection | undefined;
            };
            /**
                * @propertyNames { "pattern": "^m_[0-9a-z]{16}$" }
                */
            node: {
                    [mapId: MapId]: MVFv1NodeCollection | undefined;
            };
            /**
                * @propertyNames { "pattern": "^m_[0-9a-z]{16}$" }
                */
            connection: {
                    [mapId: MapId]: MVFv1ConnectionCollection | undefined;
            };
            'manifest.geojson': MVFv1ManifestCollection;
            'building.geojson': MVFv1BuildingCollection;
            'category.geojson': MVFv1CategoryCollection;
            'location.geojson': MVFv1LocationCollection;
    };
    export type RawMVFv1 = {
            'manifest.geojson': Uint8Array;
            'building.geojson': Uint8Array;
            'category.geojson': Uint8Array;
            'location.geojson': Uint8Array;
            level: Partial<Record<MapId, Uint8Array>>;
            node: Partial<Record<MapId, Uint8Array>>;
            space: Partial<Record<MapId, Uint8Array>>;
            obstruction: Partial<Record<MapId, Uint8Array>>;
            connection: Partial<Record<MapId, Uint8Array>>;
    };
    export {};
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/pub-sub.typed' {
    /**
        * Generic PubSub class implementing the Publish-Subscribe pattern for event handling.
        *
        * @template EVENT_PAYLOAD - The type of the event payload.
        * @template EVENT - The type of the event.
        */
    export class PubSub<EVENT_PAYLOAD, EVENT extends keyof EVENT_PAYLOAD = keyof EVENT_PAYLOAD> {
            /**
                * @private
                * @internal
                */
            _subscribers: any;
            /**
                * @private
                * @internal
                */
            publish<EVENT_NAME extends EVENT>(eventName: EVENT_NAME, data?: EVENT_PAYLOAD[EVENT_NAME]): void;
            /**
                * Subscribe a function to an event.
                *
                * @param eventName An event name which, when fired, will call the provided
                * function.
                * @param fn A callback that gets called when the corresponding event is fired. The
                * callback will get passed an argument with a type that's one of event payloads.
                * @example
                * // Subscribe to the 'click' event
                * const handler = (event) => {
                *  const { coordinate } = event;
                *  const { latitude, longitude } = coordinate;
                * 	console.log(`Map was clicked at ${latitude}, ${longitude}`);
                * };
                * map.on('click', handler);
                */
            on<EVENT_NAME extends EVENT>(eventName: EVENT_NAME, fn: (payload: EVENT_PAYLOAD[EVENT_NAME] extends {
                    data: null;
            } ? EVENT_PAYLOAD[EVENT_NAME]['data'] : EVENT_PAYLOAD[EVENT_NAME]) => void): void;
            /**
                * Unsubscribe a function previously subscribed with {@link on}
                *
                * @param eventName An event name to which the provided function was previously
                * subscribed.
                * @param fn A function that was previously passed to {@link on}. The function must
                * have the same reference as the function that was subscribed.
                * @example
                * // Unsubscribe from the 'click' event
                * const handler = (event) => {
                * 	console.log('Map was clicked', event);
                * };
                * map.off('click', handler);
                */
            off<EVENT_NAME extends EVENT>(eventName: EVENT_NAME, fn: (payload: EVENT_PAYLOAD[EVENT_NAME]) => void): void;
            /**
                * @private
                * @internal
                */
            destroy(): void;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinNavigatable' {
    import type { MappedinNode, MappedinPolygon, MappedinLocation } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import { MappedinDirections, MappedinDestinationSet, Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import { TSimplifyDirectionsOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator';
    export type TDirectionToOptions = {
            /**
                * If true directions will only take accessible routes
                * @default false
                */
            accessible?: boolean;
            /**
                * Include all the vortexes matching the given IDs
                */
            includedVortexIds?: string[];
            /**
                * Exclude all the vortexes matching the given IDs
                */
            excludedVortexIds?: string[];
            /**
                * Exclude all the nodes matching the given IDs
                */
            excludedNodeIds?: string[];
            /**
                * @experimental
                * Apply line-of-sight simplifying to directions. This will attempt to remove unnecessary nodes between turns.
                */
            simplify?: TSimplifyDirectionsOptions;
    };
    export abstract class MappedinNavigatable {
            #private;
            constructor(mappedin: Mappedin);
            /**
                *
                * Get Directions to a node, polygon, or location
                */
            directionsTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): MappedinDirections;
            directionsTo(destination: MappedinDestinationSet, options?: TDirectionToOptions): MappedinDirections[];
            /**
                *
                * Calculate walking distance in meters between 2 nodes, polygons or locations
                */
            distanceTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): number;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinNode' {
    import type { MappedinPolygon, MappedinLocation, Mappedin, MappedinDirections, MappedinMap, TDirectionToOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import type { TOpeningHours } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    import { MappedinNavigatable, MappedinDestinationSet } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * A {@link MappedinNode} represents a position, anchored to a specific {@link MappedinMap}.
        *
        * A Node can have more properties but usually the default is sufficient. The {@link Mappedin} 'things' object is where you would specify what properties you want to download for Nodes. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * @class MappedinNode
        */
    export class MappedinNode extends MappedinNavigatable {
            #private;
            static readonly __type = "MappedinNode";
            readonly __type = "MappedinNode";
            static is(instance: object): instance is MappedinNode;
            /**
                * Node ID.
                * @property id {string}
                */
            id: string;
            /**
                *  X coordinate of Node's position.
                * @property x {number}
                */
            x: number;
            /**
                * Y coordinate of Node's position.
                * @property y {number}
                */
            y: number;
            /**
                * Operation Hours of this node. A Location may have different operation hours per node, for example 2 washrooms
                */
            operationHours?: TOpeningHours[];
            externalId?: string;
            constructor(mappedin: Mappedin, data: any);
            /**
                * Map Object that this Node is located on.
                *
                * @property map {MappedinMap}
                */
            get map(): MappedinMap;
            /**
                * Latitude of node. This is expensive, especially if doing it for many/all nodes
                */
            get lat(): number;
            /**
                * Longitude of node. This is expensive, especially if doing it for many/all nodes
                */
            get lon(): number;
            /**
                * Adjacent Nodes.
                *
                * @property paths
                * @type [MappedinNode]
                */
            get paths(): MappedinNode[];
            set paths(paths: MappedinNode[]);
            /**
                * Locations attached to this Node.
                *
                * @property locations
                * @type [MappedinLocation]
                */
            get locations(): MappedinLocation[];
            /**
                * Polygon that this node is part of
                */
            get polygon(): MappedinPolygon;
            static hydrate(nodes: any, mappedin: Mappedin): MappedinNode[];
            static fetch(mappedin: Mappedin): Promise<MappedinNode[]>;
            /**
                *
                * Get Directions to a node, polygon, or location
                */
            directionsTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): MappedinDirections;
            directionsTo(destination: MappedinDestinationSet, options?: TDirectionToOptions): MappedinDirections[];
            /**
                *
                * Calculate walking distance in meters between 2 nodes, polygons or locations
                */
            distanceTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): number;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinPolygon' {
    import type { MappedinNode, MappedinLocation, Mappedin, MappedinCoordinate } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import { MappedinNavigatable, MappedinDirections, MappedinDestinationSet, MappedinMap, TDirectionToOptions } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * The {@link MappedinPolygon} class represents the 3D shape of a {@link MappedinLocation} on a {{@link MappedinMap}. Polygons have access to Locations they belong to, and any entrances to the Polygon.
        *
        * A Polygon can have more properties but usually the default is sufficient. The {@link Mappedin}'things' object is where you would specify what properties you want to download for Polygons. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * @class MappedinPolygon
        */
    export class MappedinPolygon extends MappedinNavigatable {
            #private;
            static readonly __type = "MappedinPolygon";
            readonly __type = "MappedinPolygon";
            static is(instance: object): instance is MappedinPolygon;
            geometry: any;
            perspectives?: any;
            image?: {
                    visible: boolean;
                    url: string | Blob;
                    original: string | Blob;
                    useLocalScaling: boolean;
                    viewBox: {
                            width: number;
                            height: number;
                    };
                    scale: {
                            x: number;
                            y: number;
                    };
                    fitToBounds: boolean;
                    position: {
                            x: number;
                            y: number;
                            z: number;
                    };
                    rotation: {
                            x: number;
                            y: number;
                            z: number;
                    };
                    _isAbsolutelyPositioned?: boolean;
            };
            holes?: unknown[];
            textures?: {
                    image: any;
                    name: 'front' | 'side';
                    useFrontFaceImage?: boolean;
            }[];
            material: {
                    color: string;
                    opacity?: number;
            };
            label?: {
                    visible: boolean;
                    text: string;
                    align: string;
                    position: {
                            x: number;
                            y: number;
                            z: number;
                    };
                    rotation: {
                            x: number;
                            y: number;
                            z: number;
                    };
                    fontFamily: string;
                    fontSize: number;
                    color: string;
            };
            /**
                * Node ID.
                *
                * @property id {string}
                */
            id: string;
            layer?: string;
            layerId?: string;
            name?: string;
            externalId?: string;
            vertexes?: {
                    x: number;
                    y: number;
            }[];
            /**
                * @internal
                *
                * The center coordinate of the polygon used for positioning {@link FloatingLabels} for MVF venues.
                */
            center?: {
                    x: number;
                    y: number;
            };
            canvasBounds?: {
                    align: string;
                    maxHeight: number;
                    maxWidth: number;
                    rotation: number;
                    x: number;
                    y: number;
            };
            /** Category grouped ranking determined by the {@link MappedinCategory.sortOrder} and {@link rank} for this polygon. */
            categoryRank?: number;
            constructor(mappedin: Mappedin, data: any);
            /**
                * Map Object that this Polygon is located on.
                *
                * @property map {MappedinMap}
                */
            get map(): MappedinMap;
            /**
                * Locations attached to the Polygon.
                *
                * @property locations {[MappedinLocation]}
                */
            get locations(): MappedinLocation[];
            /**
                * Polygon's entrance Nodes.
                *
                * @property entrances {[MappedinNode]}
                */
            get entrances(): MappedinNode[];
            set entrances(entrances: MappedinNode[]);
            /**
                * Ranking for this polygon.
                */
            get rank(): {
                    score: number;
                    node: string;
            } | null;
            static hydrate(polygons: any, mappedin: Mappedin): MappedinPolygon[];
            static fetch(mappedin: Mappedin): Promise<MappedinPolygon[]>;
            /**
                *
                * Get Directions to a node, polygon, or location
                */
            directionsTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): MappedinDirections;
            directionsTo(destination: MappedinDestinationSet, options?: TDirectionToOptions): MappedinDirections[];
            /**
                *
                * Calculate walking distance in meters between 2 nodes, polygons or locations
                */
            distanceTo(destination: MappedinNode | MappedinLocation | MappedinPolygon, options?: TDirectionToOptions): number;
            /**
                * Determines if a coordinate is within the polygon.
                */
            containsCoordinate(coordinate: MappedinCoordinate): boolean;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinCategory' {
    /**
        * Collection of all Categories within the Venue.
        *
        * @property categories
        * @type [MappedinCategory]
        */
    import type { MappedinLocation, Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import type { TPicture } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    /**
        * A {@link MappedinCategory} is a collection of similar Locations.
        *
        * A Category can have more properties such as 'name', or 'parents' (for hierarchical categories) as well.
        * For example, you may have a Fashion category, which has a Men's Fashion and Women's Fashion category. A Men's clothing store would belong to the Mens Fashion category, but not necessarily be present in the Fashion category's list of Locations.
        *
        * The {@link Mappedin} 'things' object is where you would specify what properties you want to download for Categories. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * See below for an example a 'things' object with available Category properties specified:
        *
        *	things: {
        *		venue: [],
        *		locations: [],
        *		categories: ['venue', 'name', 'language', 'externalId', 'parents'],
        *		maps: []
        * 	}
        *
        * @class MappedinCategory
        */
    export class MappedinCategory {
            #private;
            static readonly __type = "MappedinCategory";
            readonly __type = "MappedinCategory";
            static is(instance: object): instance is MappedinCategory;
            name?: string | undefined;
            externalId?: string | undefined;
            parents?: string[] | undefined;
            id?: string | undefined;
            icon?: TPicture | undefined;
            iconFromDefaultList?: string | undefined;
            /** Category sort priority. */
            sortOrder?: number | undefined;
            constructor(mappedin: Mappedin, data: any);
            /**
                * Locations in this Category.
                *
                * @property locations
                * @type [MappedinLocation]
                */
            get locations(): MappedinLocation[];
            /**
                * Children of this Category.
                *
                * @property children
                * @type [MappedinCategory]
                */
            get children(): MappedinCategory[];
            static hydrate(categories: any, mappedin: Mappedin): MappedinCategory[];
            static updateInPlace(mappedin: Mappedin, hydrateData?: any): Promise<void>;
            static fetch(mappedin: Mappedin): Promise<MappedinCategory[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinDestinationSet' {
    import type { MappedinNode, MappedinPolygon, MappedinLocation } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    export class MappedinDestinationSet {
        destinations: (MappedinLocation | MappedinNode | MappedinPolygon)[];
        constructor(destinations: (MappedinLocation | MappedinNode | MappedinPolygon)[]);
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinVortex' {
    import type { Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * A {@link MappedinVortex} is a special entity that represents a link between two or more {@link MappedinMap}s at a given {@link MappedinVenue}. It is typically something like an elevator or stairs. These are also known as Connections in some parts of the system.
        *
        * They can be marked (wheelchair) Accessible or not for pathfinding purposes. If you ask for Accessible directions, paths that include non-accessible Vortexes like Stairs will not be used.
        *
        * @class MappedinVortex
        */
    export class MappedinVortex {
            #private;
            static readonly __type = "MappedinVortex";
            readonly __type = "MappedinVortex";
            static is(instance: object): instance is MappedinVortex;
            /**
                * Vortex ID.
                *
                * @property id {string}
                */
            id: string;
            accessible?: boolean;
            name?: string;
            type?: string;
            weight?: number;
            multiplier?: number;
            nodes?: string[];
            filterFlags?: string[];
            constructor(data: any);
            static hydrate(vortexes: any): MappedinVortex[];
            static fetch(mappedin: Mappedin): Promise<MappedinVortex[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinVenue' {
    import type { Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import type { TLogo, TOpeningHours } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    /**
        * A {@link MappedinVenue} is a specific place (like a mall) with one or more Maps (typically representing different floors) and Locations (stores, washrooms, elevators, etc).
        *
        * A Venue can have more properties such as 'name' and 'slug'. The {@link Mappedin} 'things' object is where you would specify what properties you want to download for Venues. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * See below for an example a 'things' object with available Venue properties specified:
        *
        *	things: {
        *		venue: ['slug', 'name', 'language', 'address', 'city', 'state', 'postal', 'telephone', 'latitude', 'longitude', 'website', 'operationHours'],
        *		locations: [],
        *		categories: [],
        *		maps: []
        * 	}
        *
        *
        * @class MappedinVenue
        */
    export class MappedinVenue {
            #private;
            defaultMap: string;
            address: string;
            city: string;
            countrycode: string;
            externalId: string;
            id: string;
            latitude?: number;
            logo?: TLogo;
            longitude?: number;
            name: string;
            operationHours?: TOpeningHours[];
            postal: string;
            slug: string;
            state: string;
            telephone: string;
            tzid: string;
            tzidOverride: string;
            utcOffset: string;
            website: string;
            secureContentStorage: boolean;
            defaultLanguage: {
                    code: string;
                    name: string;
            };
            languages: {
                    name: string;
                    code: string;
            }[];
            topLocations?: string[];
            /**
                * Venue render options provided by the server.
                */
            renderOptions: {
                    /**
                        * Whether the venue should use perspectives to render the map or {@link Mappedin.polygons}.
                        */
                    useLivePolygons: boolean;
                    /**
                        * Whether the venue should automatically apply {@link TDirectionToOptions} `simplify: { enabled: true }` to all directions.
                        */
                    simplifyDirections: boolean;
            };
            constructor(mappedin: Mappedin, data: any);
            get metadata(): any;
            set metadata(value: any);
            static hydrate(data: any, mappedin: Mappedin): MappedinVenue;
            static fetch(mappedin: Mappedin): Promise<MappedinVenue>;
            get isMultiBuilding(): any;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinTheme' {
    import type { Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    export class MappedinTheme {
        #private;
        /**
          * Theme ID.
          *
          * @property id {string}
          */
        id: string;
        constructor(data: any);
        static hydrate(themes: any): MappedinTheme[];
        static fetch(mappedin: Mappedin): Promise<MappedinTheme[]>;
        toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinRankings' {
    import type { Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import type { TPolygonRanking } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    /**
      * A {@link MappedinRankings} object is something that contains all the rankings for all the {@link MappedinPolygon}s in the venue. It has a `polygons` array in which each item is linked to zero or more {@link MappedinPolygon}s.
      *
      * Rankings shows what the priority of displaying each polygon is.
      *
      * A specific polygon's ranking can have the properties `polygonId`, `entranceNodeId`, `score`.
      *
      * The {@link Mappedin} `things` object is where you would specify what type of ranking data you want to download for the venue. Only specify what you will actually use, to minimize transfer time.
      *
      * See below for an example a `things` object with the available ranking properties specified:
      *
      *	things: {
      *		venue: [],
      *		locations: [],
      *		categories: [],
      *		maps: [],
      *		rankings: ['polygons'],
      *	}
      *
      * @class MappedinRankings
      */
    export class MappedinRankings {
        #private;
        constructor(data: any);
        polygons: TPolygonRanking[];
        static hydrate(rankings: any): MappedinRankings;
        static fetch(mappedin: Mappedin): Promise<MappedinRankings | null>;
        toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinLocationRankings' {
    import type { Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import type { TLocation } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    /** One of these contains all the venue's rankings. * */
    export class MappedinLocationRankings {
        #private;
        constructor(data: any);
        locations: TLocation[];
        static hydrate(locationRankings: any): MappedinLocationRankings;
        static fetch(mappedin: Mappedin): Promise<MappedinLocationRankings>;
        toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinEvent' {
    import type { TImage } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    import type { MappedinLocation, Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * An event such as a promotion attached to a location in a venue for a period of time. Events can be created in the Mappedin CMS.
        *
        * @class MappedinEvent
        */
    export class MappedinEvent {
            #private;
            /**
                * Unique id string of the event.
                */
            id: string;
            type: string;
            /**
                * Event name
                */
            name: string;
            /**
                * Optional, longer description of the event.
                */
            description?: string | undefined;
            /**
                * Optional image to be used for displaying the event.
                */
            image?: TImage | undefined;
            /**
                * Start timestamp of the event. Javascript date in milliseconds since 1 January 1970 UTC.
                */
            startDate?: number | undefined;
            /**
                * Start timestamp of the event. Javascript date in milliseconds since 1 January 1970 UTC.
                */
            endDate?: number | undefined;
            /**
                * Timestamp when the event should be displayed. Javascript date in milliseconds since 1 January 1970 UTC.
                */
            showDate?: number | undefined;
            /**
                * @internal
                */
            constructor(mappedin: Mappedin, data: any);
            /**
                * Location this event is occuring at.
                */
            location(): MappedinLocation | undefined;
            /**
                * @internal
                */
            static hydrate(events: any, mappedin: Mappedin): MappedinEvent[];
            static updateInPlace(mappedin: Mappedin, hydrateData?: any): Promise<void>;
            /**
                * @internal
                */
            static fetch(mappedin: Mappedin): Promise<MappedinEvent[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinLocationState' {
    import type { Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * A location state, that can belong to any number of {@link MappedinLocation}s.
        * @class MappedinLocationState
        */
    export class MappedinLocationState {
            #private;
            /**
                * @internal
                */
            constructor(data: any);
            /**
                * @internal
                */
            static hydrate(locationStates: any): MappedinLocationState[];
            static updateInPlace(mappedin: Mappedin, hydrateData?: any): Promise<void>;
            id: string;
            name: string;
            value: string;
            /**
                * @internal
                */
            static fetch(mappedin: Mappedin): Promise<MappedinLocationState[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinMap' {
    import type { MappedinMapGroup, Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import type { TGeoReference } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.API.types';
    import { MappedinPolygon, MappedinLocation, MappedinCoordinate } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * A {@link MappedinMap} belonging to a specific {@link MappedinVenue}. Typically represents a certain floor. Give this to a {@link MapView} to display to the user.
        *
        * A Map can have more properties such as 'elevation', 'name' (e.g. Level 1), and 'shortName' (e.g. L1). The elevation property can be used to determine the order of the floors (first, second, etc). Elevation is 0 based, going up and down in integers representing the number of floors above or below 0, which is ground level.
        *
        * The {@link Mappedin} 'things' object is where you would specify what properties you want to download for Maps. Only specify what you will actually use, to minmimze transfer time. Work with your Mappedin developer relations contact to set up any custom properties you need.
        *
        * See below for an example a 'things' object with available Map properties specified:
        *
        *	things: {
        *		venue: [],
        *		locations: [],
        *		categories: [],
        *		maps: ['name', 'elevation', 'shortName']
        * 	}
        *
        * @class MappedinMap
        */
    export class MappedinMap {
            #private;
            static readonly __type = "MappedinMap";
            readonly __type = "MappedinMap";
            static is(instance: object): instance is MappedinMap;
            id: string;
            group: string;
            name: string;
            shortName: string;
            elevation: number;
            subtitle?: string;
            scale?: number;
            layers: {
                    visible: boolean;
                    name: string;
                    id: string;
            }[];
            x_scale?: number;
            perspectiveId?: string;
            scene: any;
            width: number;
            height: number;
            georeference: TGeoReference[];
            constructor(mappedin: Mappedin, data: any);
            _scale: number;
            /**
                * Polygons on this Map.
                *
                * @property polygons {[MappedinPolygon]}
                */
            get polygons(): MappedinPolygon[] | undefined;
            /**
                * Locations on this map
                */
            get locations(): MappedinLocation[];
            get nodes(): import("./MappedinNode").MappedinNode[];
            /**
                * Map Group this map belongs to.
                *
                * @property mapGroup {MappedinMapGroup}
                */
            get mapGroup(): MappedinMapGroup | null;
            /**
                * Create coordinate using mappedin units
                * @internal
                *
                * @param x x of coordinate
                * @param y y of coordinate
                */
            createCoordinateByXY(x: number, y: number): MappedinCoordinate;
            /**
                * Create coordinate using lat/lon
                *
                * @param lat latitude of coordinate
                * @param lon longitude of coordinate
                */
            createCoordinate(lat: number, lon: number): MappedinCoordinate;
            /**
                *
                * @returns map rotation in radians from north
                */
            getNorth(): any;
            static hydrate(maps: any, mappedin: Mappedin): MappedinMap[];
            static updateInPlace(mappedin: Mappedin, hydrateData?: any): Promise<void>;
            static fetch(mappedin: Mappedin): Promise<MappedinMap[]>;
            get center(): MappedinCoordinate;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/MappedinMapGroup' {
    import type { MappedinMap, Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    /**
        * A {@link MappedinMapGroup} is a collection of maps, usually representing the different floors of a single building. All Maps will be in a MapGroup, but if your Venue is only a single building (like a mall) you can likely ignore MapGroups entirely.
        *
        * @class MappedinMapGroup
        */
    export class MappedinMapGroup {
            #private;
            static readonly __type = "MappedinMapGroup";
            readonly __type = "MappedinMapGroup";
            static is(instance: object): instance is MappedinMapGroup;
            id: string;
            name: string;
            constructor(mappedin: Mappedin, data: any);
            /**
                * Maps within this MapGroup.
                *
                * @property maps {[MappedinMap]}
                */
            get maps(): MappedinMap[];
            static hydrate(mapGroups: any, mappedin: Mappedin): MappedinMapGroup[];
            static updateInPlace(mappedin: Mappedin, hydrateData?: any): Promise<void>;
            static fetch(mappedin: Mappedin): Promise<MappedinMapGroup[]>;
            toJSON(): any;
    }
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/utils' {
    import type { MergedThings, TGetVenueOptions, TGetVenueOptionsInternal, ThingsOption } from '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.types';
    import type { MappedinMap } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    import { Mappedin, MappedinNavigatable, MappedinNode, MappedinPolygon, MappedinLocation, MappedinCoordinate } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    export function isGatewayKey(key: string): boolean;
    export function stringifyQuery(query: any, gateway?: boolean): string;
    export function buildUrl(options: TGetVenueOptionsInternal<TGetVenueOptions>, pathname: string, query: any, supplementary?: boolean): string;
    /**
        * Make a network request to the Mappedin API to fetch an array of objects.
        * @param options options from getVenue- baseUrl and supplementaryUrl are used
        * @param pathname the type of data to request (like polygons or nodes)
        * @param query extra parameters to pass in the request
        * @param supplementary whether to use the supplementaryUrl when sending the request
        * @returns the result json
        */
    export function getArray(options: TGetVenueOptionsInternal<TGetVenueOptions>, pathname: string, query: any, supplementary?: boolean): Promise<any>;
    /**
        * Make a network request to the Mappedin API to fetch an object.
        * @param options options from getVenue- baseUrl and supplementaryUrl are used
        * @param pathname the type of data to request (like polygons or nodes)
        * @param query extra parameters to pass in the request
        * @param supplementary whether to use the supplementaryUrl when sending the request
        * @param isExpectingArray whether the endpoint returns an array
        * @returns the result json
        */
    export function getObject(options: TGetVenueOptionsInternal<TGetVenueOptions>, pathname: string, query: any, supplementary?: boolean, isExpectingArray?: boolean): Promise<any>;
    /**
        * Prepares the request and URL fields to pass into generateAPIRequest
        * @param options options from getVenue- baseUrl and supplementaryUrl are used
        * @param url string describing the url corresponding to the client's request
        * @param supplementary whether to use the supplementaryUrl when sending the request
        */
    export function constructParamsForRequest(options: TGetVenueOptionsInternal<TGetVenueOptions>, url: string, supplementary?: boolean): {
            req: {
                    method: string;
                    headers: any;
            };
            url: string;
    };
    export function generateAPIRequest(options: TGetVenueOptionsInternal<TGetVenueOptions>, url: string, supplementary?: boolean): Promise<any>;
    export function addToSet(array: any, value: any): void;
    export function getDistanceBetweenLatLon([lat1, lon1]: [number, number], [lat2, lon2]: [number, number]): any;
    export function getMapScale(map: MappedinMap): any;
    export function getNodesForNavigatable(obj: MappedinNavigatable): string[];
    export function populateBundledImagesAsBlobs(data: any): Promise<any>;
    export function getNearestNode(nodes: MappedinNode[], nodeOrCoordinate: MappedinNode | MappedinCoordinate): MappedinNode;
    export function debounce(func: any, wait: any, immediate?: any): (...args: any[]) => void;
    /**
        * Normalize the sortOrder value between 1 and 2, excluding 1 and 2.
        * Smaller sortOrder numbers result in higher priority (closer to 2) while higher numbers result in lower (closer to 1).
        * Provide an additional polygonRank for more granular ranking.
        * @param sortOrder the value of the category's sortOrder
        * @param min minimum sortOrder
        * @param max maximum sortOrder
        * @param polygonRank optional polygonRank between 0 and 1
        * @returns the normalized value
        */
    export function normalizeCategoryRank(sortOrder: number, min: number, max: number, polygonRank?: number): number;
    export function getDeviceIDFromStorage(): string;
    export function getSessionIDFromStorage(): string;
    /**
        * Finds the main Location associated with a Polygon. This means a Location
        * attached to the Polygon that has no parents, or, if there are none of those,
        * a Location nearest the top of some hierarchy that does have the Polygon attached.
        *
        * This means if there are multiple hierarchies of Locations attached to the Polygon,
        * the one that gets returned is not guaranteed to be what you want.
        *
        * @method getPrimaryLocationForPolygon
        * @param polygon {MappedinPolygon} The Polygon you want the primary Location of.
        * @return {MappedinLocation}
        */
    export const getPrimaryLocationForPolygon: (polygon: MappedinPolygon | string | undefined, venue: Mappedin) => MappedinLocation | null;
    export function mergeThings(thingsOption: ThingsOption | undefined): MergedThings;
}

declare module '@mappedin/mappedin-js/lib/esm/get-venue/Mappedin.cache' {
    import { MappedinNode, MappedinPolygon, MappedinLocation, MappedinCategory, MappedinVortex, MappedinRankings, MappedinEvent, MappedinLocationState, MappedinMap, MappedinCoordinate, MappedinMapGroup, Mappedin } from '@mappedin/mappedin-js/lib/esm/get-venue/internal';
    class MappedinCache {
        #private;
        constructor(mappedin: Mappedin);
        /**
          * Caches for getCollectionById function in `Mappedin.ts`
          * `!` is fine here, we're telling typescript that these
          * fields will be initialized at a later time (aka lazy)
          */
        categories: {
            [id: string]: MappedinCategory;
        };
        categoriesByExternalId: {
            [externalId: string]: MappedinCategory;
        };
        locations: {
            [id: string]: MappedinLocation;
        };
        locationsByExternalId: {
            [externalId: string]: MappedinLocation;
        };
        vortexes: {
            [id: string]: MappedinVortex;
        };
        vortexesByExternalId: {
            [externalId: string]: MappedinVortex;
        };
        maps: {
            [id: string]: MappedinMap;
        };
        mapsByExternalId: {
            [externalId: string]: MappedinMap;
        };
        nodes: {
            [id: string]: MappedinNode;
        };
        nodesByExternalId: {
            [externalId: string]: MappedinNode;
        };
        polygons: {
            [id: string]: MappedinPolygon;
        };
        polygonsByExternalId: {
            [externalId: string]: MappedinPolygon;
        };
        events: {
            [id: string]: MappedinEvent;
        };
        eventsByExternalId: {
            [externalId: string]: MappedinEvent;
        };
        mapGroups: {
            [id: string]: MappedinMapGroup;
        };
        mapGroupsByExternalId: {
            [externalId: string]: MappedinMapGroup;
        };
        locationStates: {
            [id: string]: MappedinLocationState;
        };
        rankings: {
            [id: string]: MappedinRankings;
        };
        languages: {
            [id: string]: string;
        };
        get polygonsByMapId(): Map<string, MappedinPolygon[]>;
        get nodesByMapId(): Map<string, MappedinNode[]>;
        findNearestNodeOnMap(mapId: string, coordinate: MappedinCoordinate): MappedinNode;
        findNodeWithinRadiusOnMap(mapId: string, coordinate: MappedinCoordinate, radius: number): MappedinNode[];
        get locationsByMapId(): Map<string, MappedinLocation[]>;
        static instances: WeakMap<Mappedin, MappedinCache>;
        static create(mappedin: Mappedin): MappedinCache;
        static clearInstance(mappedin: Mappedin): void;
    }
    export default MappedinCache;
}

import ILocation from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/ILocation';
import IMap from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/IMap';
import INode from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/INode';
export declare enum ACTION_TYPE {
    DEPARTURE = "Departure",
    TAKEVORTEX = "TakeVortex",
    EXITVORTEX = "ExitVortex",
    TURN = "Turn",
    ARRIVAL = "Arrival"
}
export declare enum BEARING_TYPE {
    STRAIGHT = "Straight",
    RIGHT = "Right",
    SLIGHTRIGHT = "SlightRight",
    LEFT = "Left",
    SLIGHTLEFT = "SlightLeft"
}
export declare enum VORTEX_DIRECTION_TYPE {
    UP = "up",
    DOWN = "down",
    NONE = "none"
}
interface IActionDeparture {
    type: ACTION_TYPE.DEPARTURE;
}
interface IActionArrival {
    type: ACTION_TYPE.ARRIVAL;
}
interface IActionTakeVortex {
    type: ACTION_TYPE.TAKEVORTEX;
    toMap: IMap;
    fromMap: IMap;
    direction: VORTEX_DIRECTION_TYPE;
}
interface IActionExitVortex {
    type: ACTION_TYPE.EXITVORTEX;
    toMap: IMap;
    fromMap: IMap;
}
interface IActionTurn {
    type: ACTION_TYPE.TURN;
    bearing: BEARING_TYPE;
    referencePosition?: string;
}
export type IAction = IActionArrival | IActionDeparture | IActionTurn | IActionTakeVortex | IActionExitVortex;
declare class Directive {
    node?: INode;
    instruction: string;
    action?: IAction;
    atLocation?: ILocation;
    type?: BEARING_TYPE;
    distance: number;
    constructor({ origin, action, distance, atLocation, instruction, }: {
        origin?: INode;
        action?: IAction;
        distance?: number;
        atLocation?: ILocation;
        instruction?: string;
    });
}
export default Directive;

import Edge from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/Edge';
import IMap from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/IMap';
import INode from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/INode';
import IVortex from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/IVortex';
export declare function getMapScale(map: IMap): number;
export declare function getAngle(origin: INode, destination: INode): number;
declare class NavigationGraph {
    edges: {
        [propName: string]: Edge[];
    };
    nodesById: {
        [propName: string]: INode;
    };
    mapsById: {
        [propName: string]: IMap;
    };
    constructor({ nodes, vortexes, maps, showVortexNames, }: {
        nodes: INode[];
        vortexes: IVortex[];
        maps: IMap[];
        showVortexNames?: boolean;
    });
    /**
      * aStar takes one or more origin node ids, one or more destination node ids
      * and returns an array of nodes that define the shortest path from an origin
      * a destination.
      *
      * @param originIds array - of one or more node ids
      * @param destinationNodeIds array - of onr or more node ids
      * @param accessible boolean - optional, if true directions will only take accessible route, defaults to false
      * @param includedVortexIds set - optional, exclude all the vertexes matching the given IDs
      * @param excludedVortexIds set - optional, exclude all the vertexes matching the given IDs
      * @param excludedNodeIds set - optional, exclude all the nodes matching the given IDs
      */
    aStar({ originIds, destinationNodeIds, accessible, includedVortexIds, excludedVortexIds, excludedNodeIds, }: {
        originIds: string[];
        destinationNodeIds: string[];
        accessible: boolean;
        includedVortexIds?: Set<string>;
        excludedVortexIds?: Set<string>;
        excludedNodeIds?: Set<string>;
    }): Edge[];
    getDistance(origin: INode, destination: INode): number;
    getShortestEuclideanDistance(origin: INode, destinations: INode[]): number;
}
export default NavigationGraph;

import Directive from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/Directive';
import Edge from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/Edge';
import { TCoordinate } from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/Navigator.utils';
import ILocation from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/ILocation';
import IMap from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/IMap';
import INode from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/INode';
import IPolygon from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/IPolygon';
import IVortex from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/IVortex';
export declare enum E_MESSAGES {
        NO_VALID_PATH = "No Valid Path Available"
}
export declare function differenceBetweenAngles(a: any, b: any): number;
export interface IDirectionsResult {
        distance: number;
        path: INode[];
        instructions: Directive[];
}
/**
    * @experimental
    * Configuration options for directions simplifying.
    */
export type TSimplifyDirectionsOptions = {
        /**
            * Enable or disable simplifying.
            */
        enabled: boolean;
        /**
            * The radius of the buffer around the path.
            * @default 1.8
            */
        bufferRadius?: number;
};
declare class Navigator {
        constructor({ locations, nodes, vortexes, maps, polygons, showVortexNames, }: {
                locations: ILocation[];
                nodes: INode[];
                vortexes: IVortex[];
                maps: IMap[];
                polygons?: IPolygon[];
                showVortexNames?: boolean;
        });
        getClosestLocationInRay(startingEdge: Edge, angleThreshold?: number, distanceThreshold?: number): ILocation | null;
        /**
            * getDirections takes one or more origin node ids, one or more destination node ids
            * and returns a distance, array of directives, and an array of nodes that define the
            * path to take.
            *
            * The returned directives array defines nodes, vortexes, and locations along the path
            * along with text directions.
            *
            * @param originIds array - of one or more node ids
            * @param destinationNodeIds array - of onr or more node ids
            * @param accessible boolean - optional, if true directions will only take accessible route, defaults to false
            * @param departFrom ILocation - optional, id and name of a location to represent start of journey
            * @param arriveAt ILocation - optional, id and name of a location to represent end of journey
            * @param includedVortexIds set - optional, exclude all the vertexes matching the given IDs
            * @param excludedVortexIds set - optional, exclude all the vertexes matching the given IDs
            */
        getDirections({ originIds, destinationNodeIds, accessible, departFrom, arriveAt, includedVortexIds, excludedVortexIds, excludedNodeIds, simplify, }: {
                originIds: string[];
                includedVortexIds?: Set<string>;
                excludedVortexIds?: Set<string>;
                excludedNodeIds?: Set<string>;
                destinationNodeIds: string[];
                accessible: boolean;
                departFrom?: ILocation;
                arriveAt?: ILocation;
                simplify?: TSimplifyDirectionsOptions;
        }): IDirectionsResult;
        /**
            * Iterates through each N step node and determines if a direct line to the next M step node intersects any polygons.
            * If it doesn't, remove all steps between the two.
            */
        simplifySteps(steps: Edge[], geometryEdges: TCoordinate[][], bufferRadius: number): Edge[];
}
export default Navigator;

export declare const MI_DEBUG_KEY = "mi-debug";
export declare enum E_SDK_LOG_LEVEL {
    LOG = 0,
    WARN = 1,
    ERROR = 2,
    SILENT = 3
}
export declare function setLoggerLevel(level: E_SDK_LOG_LEVEL): void;
declare const Logger: {
    logState: E_SDK_LOG_LEVEL;
    log(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
    assert(...args: any[]): void;
    time(label: string): void;
    timeEnd(label: string): void;
};
export default Logger;

interface ILocation {
    id: string;
    name: string;
    [propName: string]: any;
}
export default ILocation;

interface IGeoReference {
    target: {
        x: number;
        y: number;
    };
    control: {
        x: number;
        y: number;
    };
}
interface IMap {
    id: string;
    name: string;
    shortName: string;
    elevation?: number;
    scale?: number;
    x_scale?: number;
    georeference?: IGeoReference[];
    [propName: string]: any;
}
export default IMap;

interface INode {
    id: string;
    x: number;
    y: number;
    map: string;
    externalId?: string;
    [propName: string]: any;
}
export default INode;

import INode from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/INode';
import IVortex from '@mappedin/mappedin-js/lib/esm/get-venue/--/navigator/interfaces/IVortex';
declare class Edge {
    origin: INode;
    destination: INode;
    vortex?: IVortex;
    distance: number;
    angle: number;
    weight: number;
    constructor({ origin, destination, vortex, elevationDelta, distance, angle, pathWeight, }: {
        origin: INode;
        destination: INode;
        vortex?: IVortex;
        elevationDelta?: number;
        distance?: number;
        angle?: number;
        pathWeight?: number;
    });
}
export default Edge;

interface IVortex {
    id: string;
    name: string;
    type: string;
    weight: number;
    multiplier: number;
    [propName: string]: any;
}
export default IVortex;

export type TCoordinate = {
        x: number;
        y: number;
};
/**
    * Modified line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/
    * Determines the intersection point of two line segments.
    * Return null if the lines don't intersect.
    */
export declare function getLineIntersection(line1Point1: TCoordinate, line1Point2: TCoordinate, line2Point1: TCoordinate, line2Point2: TCoordinate): {
        x: number;
        y: number;
} | null;
/**
    * Offsets a line between two nodes by a certain distance.
    */
export declare function getOffsetLine(point1: TCoordinate, point2: TCoordinate, offset: number): {
        x: number;
        y: number;
}[];
/**
    * Determines if there is a line of sight between two nodes.
    */
export declare function hasLineOfSight(origin: TCoordinate, destination: TCoordinate, edges?: TCoordinate[][], bufferRadius?: number): boolean;

interface IPolygon {
    id: string;
    map: string;
    layer?: string;
    layerId?: string;
    externalId?: string;
    name?: string;
    vertexes: {
        x: number;
        y: number;
    }[];
}
export default IPolygon;

